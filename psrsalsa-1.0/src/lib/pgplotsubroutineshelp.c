#include <stdio.h>
#include <strings.h>

void printSubjectHelp(char *substr)
{
  printf("PGPLOT Subroutine Descriptions taken from http://www.astro.caltech.edu/~tjp/pgplot/\n");
  if(strcasecmp(substr, "PGARRO") == 0) {
    printf("    PGARRO -- draw an arrow\n");
    printf("\n");
    printf("\n");
    printf("void cpgarro(float x1, float y1, float x2, float y2);\n");
    printf("\n");
    printf("      SUBROUTINE PGARRO (X1, Y1, X2, Y2)\n");
    printf("      REAL X1, Y1, X2, Y2\n");
    printf("\n");
    printf("Draw an arrow from the point with world-coordinates (X1,Y1) to \n");
    printf("(X2,Y2). The size of the arrowhead at (X2,Y2) is determined by \n");
    printf("the current character size set by routine PGSCH <#PGSCH>. The default size \n");
    printf("is 1/40th of the smaller of the width or height of the view surface.\n");
    printf("The appearance of the arrowhead (shape and solid or open) is\n");
    printf("controlled by routine PGSAH <#PGSAH>.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X1, Y1 (input)  : world coordinates of the tail of the arrow.\n");
    printf(" X2, Y2 (input)  : world coordinates of the head of the arrow.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGASK") == 0) {
    printf("    PGASK -- control new page prompting\n");
    printf("\n");
    printf("\n");
    printf("void cpgask(Logical flag);\n");
    printf("\n");
    printf("      SUBROUTINE PGASK (FLAG)\n");
    printf("      LOGICAL FLAG\n");
    printf("\n");
    printf("Change the ``prompt state'' of PGPLOT. If the prompt state is\n");
    printf("ON, PGPAGE <#PGPAGE> will type ``Type RETURN for next page:'' and will wait\n");
    printf("for the user to type a carriage-return before starting a new page.\n");
    printf("The initial prompt state (after the device has been opened) is ON\n");
    printf("for interactive devices. Prompt state is always OFF for\n");
    printf("non-interactive devices.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" FLAG   (input)  : if .TRUE., and if the device is an interactive\n");
    printf("                   device, the prompt state will be set to ON. If\n");
    printf("                   .FALSE., the prompt state will be set to OFF.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGAXIS") == 0) {
    printf("    PGAXIS -- draw an axis\n");
    printf("\n");
    printf("\n");
    printf("void cpgaxis(const char *opt, float x1, float y1, float x2, float y2, \\n");
    printf("             float v1, float v2, float step, int nsub, float dmajl, \\n");
    printf("             float dmajr, float fmin, float disp, float orient);\n");
    printf("\n");
    printf("      SUBROUTINE PGAXIS (OPT, X1, Y1, X2, Y2, V1, V2, STEP, NSUB,\n");
    printf("     :                   DMAJL, DMAJR, FMIN, DISP, ORIENT)\n");
    printf("      CHARACTER*(*) OPT\n");
    printf("      REAL X1, Y1, X2, Y2, V1, V2, STEP, DMAJL, DMAJR, FMIN, DISP\n");
    printf("      REAL ORIENT\n");
    printf("      INTEGER NSUB\n");
    printf("\n");
    printf("Draw a labelled graph axis from world-coordinate position (X1,Y1) to\n");
    printf("(X2,Y2).\n");
    printf("\n");
    printf("Normally, this routine draws a standard LINEAR axis with equal\n");
    printf("subdivisions.   The quantity described by the axis runs from V1 to V2;\n");
    printf("this may be, but need not be, the same as X or Y. \n");
    printf("\n");
    printf("If the 'L' option is specified, the routine draws a LOGARITHMIC axis.\n");
    printf("In this case, the quantity described by the axis runs from 10**V1 to\n");
    printf("10**V2. A logarithmic axis always has major, labeled, tick marks \n");
    printf("spaced by one or more decades. If the major tick marks are spaced\n");
    printf("by one decade (as specified by the STEP argument), then minor\n");
    printf("tick marks are placed at 2, 3, .., 9 times each power of 10;\n");
    printf("otherwise minor tick marks are spaced by one decade. If the axis\n");
    printf("spans less than two decades, numeric labels are placed at 1, 2, and\n");
    printf("5 times each power of ten.\n");
    printf("\n");
    printf("If the axis spans less than one decade, or if it spans many decades,\n");
    printf("it is preferable to use a linear axis labeled with the logarithm of\n");
    printf("the quantity of interest.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" OPT    (input)  : a string containing single-letter codes for\n");
    printf("                   various options. The options currently\n");
    printf("                   recognized are:\n");
    printf("                   L : draw a logarithmic axis\n");
    printf("                   N : write numeric labels\n");
    printf("                   1 : force decimal labelling, instead of automatic\n");
    printf("                       choice (see PGNUMB <#PGNUMB>).\n");
    printf("                   2 : force exponential labelling, instead of\n");
    printf("                       automatic.\n");
    printf(" X1, Y1 (input)  : world coordinates of one endpoint of the axis.\n");
    printf(" X2, Y2 (input)  : world coordinates of the other endpoint of the axis.\n");
    printf(" V1     (input)  : axis value at first endpoint.\n");
    printf(" V2     (input)  : axis value at second endpoint.\n");
    printf(" STEP   (input)  : major tick marks are drawn at axis value 0.0 plus\n");
    printf("                   or minus integer multiples of STEP. If STEP=0.0,\n");
    printf("                   a value is chosen automatically.\n");
    printf(" NSUB   (input)  : minor tick marks are drawn to divide the major\n");
    printf("                   divisions into NSUB equal subdivisions (ignored if\n");
    printf("                   STEP=0.0). If NSUB <= 1, no minor tick marks are\n");
    printf("                   drawn. NSUB is ignored for a logarithmic axis.\n");
    printf(" DMAJL  (input)  : length of major tick marks drawn to left of axis\n");
    printf("                   (as seen looking from first endpoint to second), in\n");
    printf("                   units of the character height.\n");
    printf(" DMAJR  (input)  : length of major tick marks drawn to right of axis,\n");
    printf("                   in units of the character height.\n");
    printf(" FMIN   (input)  : length of minor tick marks, as fraction of major.\n");
    printf(" DISP   (input)  : displacement of baseline of tick labels to\n");
    printf("                   right of axis, in units of the character height.\n");
    printf(" ORIENT (input)  : orientation of label text, in degrees; angle between\n");
    printf("                   baseline of text and direction of axis (0-360 deg).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGBAND") == 0) {
    printf("    PGBAND -- read cursor position, with anchor\n");
    printf("\n");
    printf("\n");
    printf("int cpgband(int mode, int posn, float xref, float yref, float *x,\\n");
    printf("            float *y, char *ch_scalar);\n");
    printf("\n");
    printf("      INTEGER FUNCTION PGBAND (MODE, POSN, XREF, YREF, X, Y, CH)\n");
    printf("      INTEGER MODE, POSN\n");
    printf("      REAL XREF, YREF, X, Y\n");
    printf("      CHARACTER*(*) CH\n");
    printf("\n");
    printf("Read the cursor position and a character typed by the user.\n");
    printf("The position is returned in world coordinates.  PGBAND <#PGBAND> positions\n");
    printf("the cursor at the position specified (if POSN=1), allows the user to\n");
    printf("move the cursor using the mouse or arrow keys or whatever is available\n");
    printf("on the device. When he has positioned the cursor, the user types a\n");
    printf("single character on the keyboard; PGBAND <#PGBAND> then returns this\n");
    printf("character and the new cursor position (in world coordinates).\n");
    printf("\n");
    printf("Some interactive devices offer a selection of cursor types,\n");
    printf("implemented as thin lines that move with the cursor, but without\n");
    printf("erasing underlying graphics. Of these types, some extend between\n");
    printf("a stationary anchor-point at XREF,YREF, and the position of the\n");
    printf("cursor, while others simply follow the cursor without changing shape\n");
    printf("or size. The cursor type is specified with one of the following MODE\n");
    printf("values. Cursor types that are not supported by a given device, are\n");
    printf("treated as MODE=0.\n");
    printf("\n");
    printf("-- If MODE=0, the anchor point is ignored and the routine behaves\n");
    printf("like PGCURS <#PGCURS>.\n");
    printf("-- If MODE=1, a straight line is drawn joining the anchor point \n");
    printf("and the cursor position.\n");
    printf("-- If MODE=2, a hollow rectangle is extended as the cursor is moved,\n");
    printf("with one vertex at the anchor point and the opposite vertex at the\n");
    printf("current cursor position; the edges of the rectangle are horizontal\n");
    printf("and vertical.\n");
    printf("-- If MODE=3, two horizontal lines are extended across the width of\n");
    printf("the display, one drawn through the anchor point and the other\n");
    printf("through the moving cursor position. This could be used to select\n");
    printf("a Y-axis range when one end of the range is known.\n");
    printf("-- If MODE=4, two vertical lines are extended over the height of\n");
    printf("the display, one drawn through the anchor point and the other\n");
    printf("through the moving cursor position. This could be used to select an\n");
    printf("X-axis range when one end of the range is known.\n");
    printf("-- If MODE=5, a horizontal line is extended through the cursor\n");
    printf("position over the width of the display. This could be used to select\n");
    printf("an X-axis value such as the start of an X-axis range. The anchor point\n");
    printf("is ignored.\n");
    printf("-- If MODE=6, a vertical line is extended through the cursor\n");
    printf("position over the height of the display. This could be used to select\n");
    printf("a Y-axis value such as the start of a Y-axis range. The anchor point\n");
    printf("is ignored.\n");
    printf("-- If MODE=7, a cross-hair, centered on the cursor, is extended over\n");
    printf("the width and height of the display. The anchor point is ignored.\n");
    printf("\n");
    printf("Returns:\n");
    printf(" PGBAND <#PGBAND>          : 1 if the call was successful; 0 if the device\n");
    printf("                   has no cursor or some other error occurs.\n");
    printf("Arguments:\n");
    printf(" MODE   (input)  : display mode (0, 1, ..7: see above).\n");
    printf(" POSN   (input)  : if POSN=1, PGBAND <#PGBAND> attempts to place the cursor\n");
    printf("                   at point (X,Y); if POSN=0, it leaves the cursor\n");
    printf("                   at its current position. (On some devices this\n");
    printf("                   request may be ignored.)\n");
    printf(" XREF   (input)  : the world x-coordinate of the anchor point.\n");
    printf(" YREF   (input)  : the world y-coordinate of the anchor point.\n");
    printf(" X      (in/out) : the world x-coordinate of the cursor.\n");
    printf(" Y      (in/out) : the world y-coordinate of the cursor.\n");
    printf(" CH     (output) : the character typed by the user; if the device has\n");
    printf("                   no cursor or if some other error occurs, the value\n");
    printf("                   CHAR(0) [ASCII NUL character] is returned.\n");
    printf("\n");
    printf("Note: The cursor coordinates (X,Y) may be changed by PGBAND <#PGBAND> even if\n");
    printf("the device has no cursor or if the user does not move the cursor.\n");
    printf("Under these circumstances, the position returned in (X,Y) is that of\n");
    printf("the pixel nearest to the requested position.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGBBUF") == 0) {
    printf("    PGBBUF -- begin batch of output (buffer)\n");
    printf("\n");
    printf("\n");
    printf("void cpgbbuf(void);\n");
    printf("\n");
    printf("      SUBROUTINE PGBBUF\n");
    printf("\n");
    printf("Begin saving graphical output commands in an internal buffer; the\n");
    printf("commands are held until a matching PGEBUF <#PGEBUF> call (or until the buffer\n");
    printf("is emptied by PGUPDT <#PGUPDT>). This can greatly improve the efficiency of\n");
    printf("PGPLOT.  PGBBUF <#PGBBUF> increments an internal counter, while PGEBUF <#PGEBUF>\n");
    printf("decrements this counter and flushes the buffer to the output\n");
    printf("device when the counter drops to zero.  PGBBUF <#PGBBUF> and PGEBUF <#PGEBUF> calls\n");
    printf("should always be paired.\n");
    printf("\n");
    printf("Arguments: none\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGBEG") == 0) {
    printf("    PGBEG -- open a graphics device\n");
    printf("\n");
    printf("\n");
    printf("int cpgbeg(int unit, const char *file, int nxsub, int nysub);\n");
    printf("\n");
    printf("      INTEGER FUNCTION PGBEG (UNIT, FILE, NXSUB, NYSUB)\n");
    printf("      INTEGER       UNIT\n");
    printf("      CHARACTER*(*) FILE\n");
    printf("      INTEGER       NXSUB, NYSUB\n");
    printf("\n");
    printf("Note: new programs should use PGOPEN <#PGOPEN> rather than PGBEG <#PGBEG>. PGOPEN\n");
    printf("is retained for compatibility with existing programs. Unlike PGOPEN <#PGOPEN>,\n");
    printf("PGBEG <#PGBEG> closes any graphics devices that are already open, so it \n");
    printf("cannot be used to open devices to be used in parallel.\n");
    printf("\n");
    printf("PGBEG <#PGBEG> opens a graphical device or file and prepares it for\n");
    printf("subsequent plotting. A device must be opened with PGBEG <#PGBEG> or PGOPEN <#PGOPEN>\n");
    printf("before any other calls to PGPLOT subroutines for the device.\n");
    printf("\n");
    printf("If any device  is already open for PGPLOT output, it is closed before\n");
    printf("the new device is opened.\n");
    printf("\n");
    printf("Returns:\n");
    printf(" PGBEG <#PGBEG>         : a status return value. A value of 1 indicates\n");
    printf("                   successful completion, any other value indicates\n");
    printf("                   an error. In the event of error a message is\n");
    printf("                   written on the standard error unit.  \n");
    printf("                   To test the return value, call\n");
    printf("                   PGBEG <#PGBEG> as a function, eg IER=PGBEG(...); note\n");
    printf("                   that PGBEG <#PGBEG> must be declared INTEGER in the\n");
    printf("                   calling program. Some Fortran compilers allow\n");
    printf("                   you to use CALL PGBEG <#PGBEG>(...) and discard the\n");
    printf("                   return value, but this is not standard Fortran.\n");
    printf("Arguments:\n");
    printf(" UNIT  (input)   : this argument is ignored by PGBEG <#PGBEG> (use zero).\n");
    printf(" FILE  (input)   : the \"device specification\" for the plot device.\n");
    printf("                   (For explanation, see description of PGOPEN <#PGOPEN>.)\n");
    printf(" NXSUB  (input)  : the number of subdivisions of the view surface in\n");
    printf("                   X (>0 or <0).\n");
    printf(" NYSUB  (input)  : the number of subdivisions of the view surface in\n");
    printf("                   Y (>0).\n");
    printf("                   PGPLOT puts NXSUB x NYSUB graphs on each plot\n");
    printf("                   page or screen; when the view surface is sub-\n");
    printf("                   divided in this way, PGPAGE <#PGPAGE> moves to the next\n");
    printf("                   panel, not the  next physical page. If\n");
    printf("                   NXSUB > 0, PGPLOT uses the panels in row\n");
    printf("                   order; if <0, PGPLOT uses them in column order.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGBIN") == 0) {
    printf("    PGBIN -- histogram of binned data\n");
    printf("\n");
    printf("\n");
    printf("void cpgbin(int nbin, const float *x, const float *data, \\n");
    printf(" Logical center);\n");
    printf("\n");
    printf("      SUBROUTINE PGBIN (NBIN, X, DATA, CENTER)\n");
    printf("      INTEGER NBIN\n");
    printf("      REAL X(*), DATA(*)\n");
    printf("      LOGICAL CENTER\n");
    printf("\n");
    printf("Plot a histogram of NBIN values with X(1..NBIN) values along\n");
    printf("the ordinate, and DATA(1...NBIN) along the abscissa. Bin width is\n");
    printf("spacing between X values.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" NBIN   (input)  : number of values.\n");
    printf(" X      (input)  : abscissae of bins.\n");
    printf(" DATA   (input)  : data values of bins.\n");
    printf(" CENTER (input)  : if .TRUE., the X values denote the center of the\n");
    printf("                   bin; if .FALSE., the X values denote the lower\n");
    printf("                   edge (in X) of the bin.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGBOX") == 0) {
    printf("    PGBOX -- draw labeled frame around viewport\n");
    printf("\n");
    printf("\n");
    printf("void cpgbox(const char *xopt, float xtick, int nxsub, \\n");
    printf(" const char *yopt, float ytick, int nysub);\n");
    printf("\n");
    printf("      SUBROUTINE PGBOX (XOPT, XTICK, NXSUB, YOPT, YTICK, NYSUB)\n");
    printf("      CHARACTER*(*) XOPT, YOPT\n");
    printf("      REAL XTICK, YTICK\n");
    printf("      INTEGER NXSUB, NYSUB\n");
    printf("\n");
    printf("Annotate the viewport with frame, axes, numeric labels, etc.\n");
    printf("PGBOX <#PGBOX> is called by on the user's behalf by PGENV <#PGENV>, but may also be\n");
    printf("called explicitly.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" XOPT   (input)  : string of options for X (horizontal) axis of\n");
    printf("                   plot. Options are single letters, and may be in\n");
    printf("                   any order (see below).\n");
    printf(" XTICK  (input)  : world coordinate interval between major tick marks\n");
    printf("                   on X axis. If XTICK=0.0, the interval is chosen by\n");
    printf("                   PGBOX <#PGBOX>, so that there will be at least 3 major tick\n");
    printf("                   marks along the axis.\n");
    printf(" NXSUB  (input)  : the number of subintervals to divide the major\n");
    printf("                   coordinate interval into. If XTICK=0.0 or NXSUB=0,\n");
    printf("                   the number is chosen by PGBOX <#PGBOX>.\n");
    printf(" YOPT   (input)  : string of options for Y (vertical) axis of plot.\n");
    printf("                   Coding is the same as for XOPT.\n");
    printf(" YTICK  (input)  : like XTICK for the Y axis.\n");
    printf(" NYSUB  (input)  : like NXSUB for the Y axis.\n");
    printf("\n");
    printf("Options (for parameters XOPT and YOPT):\n");
    printf(" A : draw Axis (X axis is horizontal line Y=0, Y axis is vertical\n");
    printf("     line X=0).\n");
    printf(" B : draw bottom (X) or left (Y) edge of frame.\n");
    printf(" C : draw top (X) or right (Y) edge of frame.\n");
    printf(" G : draw Grid of vertical (X) or horizontal (Y) lines.\n");
    printf(" I : Invert the tick marks; ie draw them outside the viewport\n");
    printf("     instead of inside.\n");
    printf(" L : label axis Logarithmically (see below).\n");
    printf(" N : write Numeric labels in the conventional location below the\n");
    printf("     viewport (X) or to the left of the viewport (Y).\n");
    printf(" P : extend (\"Project\") major tick marks outside the box (ignored if\n");
    printf("     option I is specified).\n");
    printf(" M : write numeric labels in the unconventional location above the\n");
    printf("     viewport (X) or to the right of the viewport (Y).\n");
    printf(" T : draw major Tick marks at the major coordinate interval.\n");
    printf(" S : draw minor tick marks (Subticks).\n");
    printf(" V : orient numeric labels Vertically. This is only applicable to Y.\n");
    printf("     The default is to write Y-labels parallel to the axis.\n");
    printf(" 1 : force decimal labelling, instead of automatic choice (see PGNUMB <#PGNUMB>).\n");
    printf(" 2 : force exponential labelling, instead of automatic.\n");
    printf("\n");
    printf("To get a complete frame, specify BC in both XOPT and YOPT.\n");
    printf("Tick marks, if requested, are drawn on the axes or frame\n");
    printf("or both, depending which are requested. If none of ABC is specified,\n");
    printf("tick marks will not be drawn. When PGENV <#PGENV> calls PGBOX <#PGBOX>, it sets both\n");
    printf("XOPT and YOPT according to the value of its parameter AXIS:\n");
    printf("-1: 'BC', 0: 'BCNST', 1: 'ABCNST', 2: 'ABCGNST'.\n");
    printf("\n");
    printf("For a logarithmic axis, the major tick interval is always 1.0. The\n");
    printf("numeric label is 10**(x) where x is the world coordinate at the\n");
    printf("tick mark. If subticks are requested, 8 subticks are drawn between\n");
    printf("each major tick at equal logarithmic intervals.\n");
    printf("\n");
    printf("To label an axis with time (days, hours, minutes, seconds) or\n");
    printf("angle (degrees, arcmin, arcsec), use routine PGTBOX <#PGTBOX>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGCIRC") == 0) {
    printf("    PGCIRC -- draw a circle, using fill-area attributes\n");
    printf("\n");
    printf("\n");
    printf("void cpgcirc(float xcent, float ycent, float radius);\n");
    printf("\n");
    printf("      SUBROUTINE PGCIRC (XCENT, YCENT, RADIUS)\n");
    printf("      REAL XCENT, YCENT, RADIUS\n");
    printf("\n");
    printf("Draw a circle. The action of this routine depends\n");
    printf("on the setting of the Fill-Area Style attribute. If Fill-Area Style\n");
    printf("is SOLID (the default), the interior of the circle is solid-filled\n");
    printf("using the current Color Index. If Fill-Area Style is HOLLOW, the\n");
    printf("outline of the circle is drawn using the current line attributes\n");
    printf("(color index, line-style, and line-width).\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" XCENT  (input)  : world x-coordinate of the center of the circle.\n");
    printf(" YCENT  (input)  : world y-coordinate of the center of the circle.\n");
    printf(" RADIUS (input)  : radius of circle (world coordinates).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGCLOS") == 0) {
    printf("    PGCLOS -- close the selected graphics device\n");
    printf("\n");
    printf("\n");
    printf("void cpgclos(void);\n");
    printf("\n");
    printf("      SUBROUTINE PGCLOS\n");
    printf("\n");
    printf("Close the currently selected graphics device. After the device has\n");
    printf("been closed, either another open device must be selected with PGSLCT <#PGSLCT>\n");
    printf("or another device must be opened with PGOPEN <#PGOPEN> before any further\n");
    printf("plotting can be done. If the call to PGCLOS <#PGCLOS> is omitted, some or all \n");
    printf("of the plot may be lost.\n");
    printf("\n");
    printf("[This routine was added to PGPLOT in Version 5.1.0. Older programs\n");
    printf("use PGEND <#PGEND> instead.]\n");
    printf("\n");
    printf("Arguments: none\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGCONB") == 0) {
    printf("    PGCONB -- contour map of a 2D data array, with blanking\n");
    printf("\n");
    printf("\n");
    printf("void cpgconb(const float *a, int idim, int jdim, int i1, int i2, \\n");
    printf(" int j1, int j2, const float *c, int nc, const float *tr, \\n");
    printf(" float blank);\n");
    printf("\n");
    printf("      SUBROUTINE PGCONB (A, IDIM, JDIM, I1, I2, J1, J2, C, NC, TR, \n");
    printf("     1                   BLANK)\n");
    printf("      INTEGER IDIM, JDIM, I1, I2, J1, J2, NC\n");
    printf("      REAL    A(IDIM,JDIM), C(*), TR(6), BLANK\n");
    printf("\n");
    printf("Draw a contour map of an array. This routine is the same as PGCONS <#PGCONS>,\n");
    printf("except that array elements that have the \"magic value\" defined by\n");
    printf("argument BLANK are ignored, making gaps in the contour map. The\n");
    printf("routine may be useful for data measured on most but not all of the\n");
    printf("points of a grid.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" A      (input)  : data array.\n");
    printf(" IDIM   (input)  : first dimension of A.\n");
    printf(" JDIM   (input)  : second dimension of A.\n");
    printf(" I1,I2  (input)  : range of first index to be contoured (inclusive).\n");
    printf(" J1,J2  (input)  : range of second index to be contoured (inclusive).\n");
    printf(" C      (input)  : array of contour levels (in the same units as the\n");
    printf("                   data in array A); dimension at least NC.\n");
    printf(" NC     (input)  : number of contour levels (less than or equal to\n");
    printf("                   dimension of C). The absolute value of this\n");
    printf("                   argument is used (for compatibility with PGCONT <#PGCONT>,\n");
    printf("                   where the sign of NC is significant).\n");
    printf(" TR     (input)  : array defining a transformation between the I,J\n");
    printf("                   grid of the array and the world coordinates. The\n");
    printf("                   world coordinates of the array point A(I,J) are\n");
    printf("                   given by:\n");
    printf("                     X = TR(1) + TR(2)*I + TR(3)*J\n");
    printf("                     Y = TR(4) + TR(5)*I + TR(6)*J\n");
    printf("                   Usually TR(3) and TR(5) are zero - unless the\n");
    printf("                   coordinate transformation involves a rotation\n");
    printf("                   or shear.\n");
    printf(" BLANK   (input) : elements of array A that are exactly equal to\n");
    printf("                   this value are ignored (blanked).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGCONF") == 0) {
    printf("    PGCONF -- fill between two contours\n");
    printf("\n");
    printf("\n");
    printf("void cpgconf(const float *a, int idim, int jdim, int i1, int i2, \\n");
    printf(" int j1, int j2, float c1, float c2, const float *tr);\n");
    printf("\n");
    printf("      SUBROUTINE PGCONF (A, IDIM, JDIM, I1, I2, J1, J2, C1, C2, TR)\n");
    printf("      INTEGER IDIM, JDIM, I1, I2, J1, J2\n");
    printf("      REAL    A(IDIM,JDIM), C1, C2, TR(6)\n");
    printf("\n");
    printf("Shade the region between two contour levels of a function defined on\n");
    printf("the nodes of a rectangular grid. The routine uses the current fill\n");
    printf("attributes, hatching style (if appropriate), and color index.\n");
    printf("\n");
    printf("If you want to both shade between contours and draw the contour\n");
    printf("lines, call this routine first (once for each pair of levels) and \n");
    printf("then CALL PGCONT <#PGCONT> (or PGCONS <#PGCONS>) to draw the contour lines on top of the\n");
    printf("shading.\n");
    printf("\n");
    printf("Note 1: This routine is not very efficient: it generates a polygon\n");
    printf("fill command for each cell of the mesh that intersects the desired\n");
    printf("area, rather than consolidating adjacent cells into a single polygon.\n");
    printf("\n");
    printf("Note 2: If both contours intersect all four edges of a particular\n");
    printf("mesh cell, the program behaves badly and may consider some parts\n");
    printf("of the cell to lie in more than one contour range.\n");
    printf("\n");
    printf("Note 3: If a contour crosses all four edges of a cell, this\n");
    printf("routine may not generate the same contours as PGCONT <#PGCONT> or PGCONS <#PGCONS>\n");
    printf("(these two routines may not agree either). Such cases are always\n");
    printf("ambiguous and the routines use different approaches to resolving\n");
    printf("the ambiguity.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" A      (input)  : data array.\n");
    printf(" IDIM   (input)  : first dimension of A.\n");
    printf(" JDIM   (input)  : second dimension of A.\n");
    printf(" I1,I2  (input)  : range of first index to be contoured (inclusive).\n");
    printf(" J1,J2  (input)  : range of second index to be contoured (inclusive).\n");
    printf(" C1, C2 (input)  : contour levels; note that C1 must be less than C2.\n");
    printf(" TR     (input)  : array defining a transformation between the I,J\n");
    printf("                   grid of the array and the world coordinates. The\n");
    printf("                   world coordinates of the array point A(I,J) are\n");
    printf("                   given by:\n");
    printf("                     X = TR(1) + TR(2)*I + TR(3)*J\n");
    printf("                     Y = TR(4) + TR(5)*I + TR(6)*J\n");
    printf("                   Usually TR(3) and TR(5) are zero - unless the\n");
    printf("                   coordinate transformation involves a rotation\n");
    printf("                   or shear.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGCONL") == 0) {
    printf("    PGCONL -- label contour map of a 2D data array\n");
    printf("\n");
    printf("\n");
    printf("void cpgconl(const float *a, int idim, int jdim, int i1, int i2, \\n");
    printf(" int j1, int j2, float c, const float *tr, const char *label, \\n");
    printf(" int intval, int minint);\n");
    printf("\n");
    printf("      SUBROUTINE PGCONL (A, IDIM, JDIM, I1, I2, J1, J2, C, TR,\n");
    printf("     1                   LABEL, INTVAL, MININT)\n");
    printf("      INTEGER IDIM, JDIM, I1, J1, I2, J2, INTVAL, MININT\n");
    printf("      REAL A(IDIM,JDIM), C, TR(6)\n");
    printf("      CHARACTER*(*) LABEL\n");
    printf("\n");
    printf("Label a contour map drawn with routine PGCONT <#PGCONT>. Routine PGCONT should\n");
    printf("be called first to draw the contour lines, then this routine should be\n");
    printf("called to add the labels. Labels are written at intervals along the\n");
    printf("contour lines, centered on the contour lines with lettering aligned\n");
    printf("in the up-hill direction. Labels are opaque, so a part of the under-\n");
    printf("lying contour line is obscured by the label. Labels use the current\n");
    printf("attributes (character height, line width, color index, character\n");
    printf("font).\n");
    printf("\n");
    printf("The first 7 arguments, and the 9th argument (TR), are the same as\n");
    printf("the corresponding arguments to PGCONT <#PGCONT>, and they should normally be\n");
    printf("identical to those used with PGCONT <#PGCONT>. Note that the argument C is not\n");
    printf("an array (unlike PGCONT <#PGCONT>): only one contour level can be specified;\n");
    printf("to label more contours, call PGCONL <#PGCONL> for each level.\n");
    printf("\n");
    printf("The label is supplied as a character string in argument LABEL.\n");
    printf("\n");
    printf("The spacing of labels along the contour is specified by parameters\n");
    printf("INTVAL and MININT. The routine follows the contour through the\n");
    printf("array, counting the number of cells that the contour crosses. The\n");
    printf("first label will be written in the MININT'th cell, and additional\n");
    printf("labels will be written every INTVAL cells thereafter. A contour\n");
    printf("that crosses less than MININT cells will not be labelled. Some\n");
    printf("experimentation may be needed to get satisfactory results; a good\n");
    printf("place to start is INTVAL=20, MININT=10.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" A      (input) : data array.\n");
    printf(" IDIM   (input) : first dimension of A.\n");
    printf(" JDIM   (input) : second dimension of A.\n");
    printf(" I1, I2 (input) : range of first index to be contoured (inclusive).\n");
    printf(" J1, J2 (input) : range of second index to be contoured (inclusive).\n");
    printf(" C      (input) : the level of the contour to be labelled (one of the\n");
    printf("                  values given to PGCONT <#PGCONT>).\n");
    printf(" TR     (input) : array defining a transformation between the I,J\n");
    printf("                  grid of the array and the world coordinates.\n");
    printf("                  The world coordinates of the array point A(I,J)\n");
    printf("                  are given by:\n");
    printf("                    X = TR(1) + TR(2)*I + TR(3)*J\n");
    printf("                    Y = TR(4) + TR(5)*I + TR(6)*J\n");
    printf("                  Usually TR(3) and TR(5) are zero - unless the\n");
    printf("                  coordinate transformation involves a rotation or\n");
    printf("                  shear.\n");
    printf(" LABEL  (input) : character strings to be used to label the specified\n");
    printf("                  contour. Leading and trailing blank spaces are\n");
    printf("                  ignored.\n");
    printf(" INTVAL (input) : spacing along the contour between labels, in\n");
    printf("                  grid cells.\n");
    printf(" MININT (input) : contours that cross less than MININT cells\n");
    printf("                  will not be labelled.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGCONS") == 0) {
    printf("    PGCONS -- contour map of a 2D data array (fast algorithm)\n");
    printf("\n");
    printf("\n");
    printf("void cpgcons(const float *a, int idim, int jdim, int i1, int i2, \\n");
    printf(" int j1, int j2, const float *c, int nc, const float *tr);\n");
    printf("\n");
    printf("      SUBROUTINE PGCONS (A, IDIM, JDIM, I1, I2, J1, J2, C, NC, TR)\n");
    printf("      INTEGER IDIM, JDIM, I1, I2, J1, J2, NC\n");
    printf("      REAL    A(IDIM,JDIM), C(*), TR(6)\n");
    printf("\n");
    printf("Draw a contour map of an array. The map is truncated if\n");
    printf("necessary at the boundaries of the viewport.  Each contour line is\n");
    printf("drawn with the current line attributes (color index, style, and\n");
    printf("width).  This routine, unlike PGCONT <#PGCONT>, does not draw each contour as a\n");
    printf("continuous line, but draws the straight line segments composing each\n");
    printf("contour in a random order.  It is thus not suitable for use on pen\n");
    printf("plotters, and it usually gives unsatisfactory results with dashed or\n");
    printf("dotted lines.  It is, however, faster than PGCONT <#PGCONT>, especially if\n");
    printf("several contour levels are drawn with one call of PGCONS <#PGCONS>.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" A      (input)  : data array.\n");
    printf(" IDIM   (input)  : first dimension of A.\n");
    printf(" JDIM   (input)  : second dimension of A.\n");
    printf(" I1,I2  (input)  : range of first index to be contoured (inclusive).\n");
    printf(" J1,J2  (input)  : range of second index to be contoured (inclusive).\n");
    printf(" C      (input)  : array of contour levels (in the same units as the\n");
    printf("                   data in array A); dimension at least NC.\n");
    printf(" NC     (input)  : number of contour levels (less than or equal to\n");
    printf("                   dimension of C). The absolute value of this\n");
    printf("                   argument is used (for compatibility with PGCONT <#PGCONT>,\n");
    printf("                   where the sign of NC is significant).\n");
    printf(" TR     (input)  : array defining a transformation between the I,J\n");
    printf("                   grid of the array and the world coordinates. The\n");
    printf("                   world coordinates of the array point A(I,J) are\n");
    printf("                   given by:\n");
    printf("                     X = TR(1) + TR(2)*I + TR(3)*J\n");
    printf("                     Y = TR(4) + TR(5)*I + TR(6)*J\n");
    printf("                   Usually TR(3) and TR(5) are zero - unless the\n");
    printf("                   coordinate transformation involves a rotation\n");
    printf("                   or shear.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGCONT") == 0) {
    printf("    PGCONT -- contour map of a 2D data array (contour-following)\n");
    printf("\n");
    printf("\n");
    printf("void cpgcont(const float *a, int idim, int jdim, int i1, int i2, \\n");
    printf(" int j1, int j2, const float *c, int nc, const float *tr);\n");
    printf("\n");
    printf("      SUBROUTINE PGCONT (A, IDIM, JDIM, I1, I2, J1, J2, C, NC, TR)\n");
    printf("      INTEGER IDIM, JDIM, I1, J1, I2, J2, NC\n");
    printf("      REAL A(IDIM,JDIM), C(*), TR(6)\n");
    printf("\n");
    printf("Draw a contour map of an array.  The map is truncated if\n");
    printf("necessary at the boundaries of the viewport.  Each contour line\n");
    printf("is drawn with the current line attributes (color index, style, and\n");
    printf("width); except that if argument NC is positive (see below), the line\n");
    printf("style is set by PGCONT <#PGCONT> to 1 (solid) for positive contours or 2\n");
    printf("(dashed) for negative contours.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" A      (input) : data array.\n");
    printf(" IDIM   (input) : first dimension of A.\n");
    printf(" JDIM   (input) : second dimension of A.\n");
    printf(" I1, I2 (input) : range of first index to be contoured (inclusive).\n");
    printf(" J1, J2 (input) : range of second index to be contoured (inclusive).\n");
    printf(" C      (input) : array of NC contour levels; dimension at least NC.\n");
    printf(" NC     (input) : +/- number of contour levels (less than or equal\n");
    printf("                  to dimension of C). If NC is positive, it is the\n");
    printf("                  number of contour levels, and the line-style is\n");
    printf("                  chosen automatically as described above. If NC is\n");
    printf("                  negative, it is minus the number of contour\n");
    printf("                  levels, and the current setting of line-style is\n");
    printf("                  used for all the contours.\n");
    printf(" TR     (input) : array defining a transformation between the I,J\n");
    printf("                  grid of the array and the world coordinates.\n");
    printf("                  The world coordinates of the array point A(I,J)\n");
    printf("                  are given by:\n");
    printf("                    X = TR(1) + TR(2)*I + TR(3)*J\n");
    printf("                    Y = TR(4) + TR(5)*I + TR(6)*J\n");
    printf("                  Usually TR(3) and TR(5) are zero - unless the\n");
    printf("                  coordinate transformation involves a rotation or\n");
    printf("                  shear.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGCONX") == 0) {
    printf("    PGCONX -- contour map of a 2D data array (non rectangular)\n");
    printf("\n");
    printf("      SUBROUTINE PGCONX (A, IDIM, JDIM, I1, I2, J1, J2, C, NC, PLOT)\n");
    printf("      INTEGER  IDIM, JDIM, I1, J1, I2, J2, NC\n");
    printf("      REAL     A(IDIM,JDIM), C(*)\n");
    printf("      EXTERNAL PLOT\n");
    printf("\n");
    printf("Draw a contour map of an array using a user-supplied plotting\n");
    printf("routine.  This routine should be used instead of PGCONT <#PGCONT> when the\n");
    printf("data are defined on a non-rectangular grid.  PGCONT <#PGCONT> permits only\n");
    printf("a linear transformation between the (I,J) grid of the array\n");
    printf("and the world coordinate system (x,y), but PGCONX <#PGCONX> permits any\n");
    printf("transformation to be used, the transformation being defined by a\n");
    printf("user-supplied subroutine. The nature of the contouring algorithm,\n");
    printf("however, dictates that the transformation should maintain the\n");
    printf("rectangular topology of the grid, although grid-points may be\n");
    printf("allowed to coalesce.  As an example of a deformed rectangular\n");
    printf("grid, consider data given on the polar grid theta=0.1n(pi/2),\n");
    printf("for n=0,1,...,10, and r=0.25m, for m=0,1,..,4. This grid\n");
    printf("contains 55 points, of which 11 are coincident at the origin.\n");
    printf("The input array for PGCONX <#PGCONX> should be dimensioned (11,5), and\n");
    printf("data values should be provided for all 55 elements.  PGCONX <#PGCONX> can\n");
    printf("also be used for special applications in which the height of the\n");
    printf("contour affects its appearance, e.g., stereoscopic views.\n");
    printf("\n");
    printf("The map is truncated if necessary at the boundaries of the viewport.\n");
    printf("Each contour line is drawn with the current line attributes (color\n");
    printf("index, style, and width); except that if argument NC is positive\n");
    printf("(see below), the line style is set by PGCONX <#PGCONX> to 1 (solid) for\n");
    printf("positive contours or 2 (dashed) for negative contours. Attributes\n");
    printf("for the contour lines can also be set in the user-supplied\n");
    printf("subroutine, if desired.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" A      (input) : data array.\n");
    printf(" IDIM   (input) : first dimension of A.\n");
    printf(" JDIM   (input) : second dimension of A.\n");
    printf(" I1, I2 (input) : range of first index to be contoured (inclusive).\n");
    printf(" J1, J2 (input) : range of second index to be contoured (inclusive).\n");
    printf(" C      (input) : array of NC contour levels; dimension at least NC.\n");
    printf(" NC     (input) : +/- number of contour levels (less than or equal\n");
    printf("                  to dimension of C). If NC is positive, it is the\n");
    printf("                  number of contour levels, and the line-style is\n");
    printf("                  chosen automatically as described above. If NC is\n");
    printf("                  negative, it is minus the number of contour\n");
    printf("                  levels, and the current setting of line-style is\n");
    printf("                  used for all the contours.\n");
    printf(" PLOT   (input) : the address (name) of a subroutine supplied by\n");
    printf("                  the user, which will be called by PGCONX <#PGCONX> to do\n");
    printf("                  the actual plotting. This must be declared\n");
    printf("                  EXTERNAL in the program unit calling PGCONX <#PGCONX>.\n");
    printf("\n");
    printf("The subroutine PLOT will be called with four arguments:\n");
    printf("     CALL PLOT(VISBLE,X,Y,Z)\n");
    printf("where X,Y (input) are real variables corresponding to\n");
    printf("I,J indices of the array A. If  VISBLE (input, integer) is 1,\n");
    printf("PLOT should draw a visible line from the current pen\n");
    printf("position to the world coordinate point corresponding to (X,Y);\n");
    printf("if it is 0, it should move the pen to (X,Y). Z is the value\n");
    printf("of the current contour level, and may be used by PLOT if desired.\n");
    printf("Example:\n");
    printf("      SUBROUTINE PLOT (VISBLE,X,Y,Z)\n");
    printf("      REAL X, Y, Z, XWORLD, YWORLD\n");
    printf("      INTEGER VISBLE\n");
    printf("      XWORLD = X*COS(Y) ! this is the user-defined\n");
    printf("      YWORLD = X*SIN(Y) ! transformation\n");
    printf("      IF (VISBLE.EQ.0) THEN\n");
    printf("          CALL PGMOVE <#PGMOVE> (XWORLD, YWORLD)\n");
    printf("      ELSE\n");
    printf("          CALL PGDRAW <#PGDRAW> (XWORLD, YWORLD)\n");
    printf("      END IF\n");
    printf("      END\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGCTAB") == 0) {
    printf("    PGCTAB -- install the color table to be used by PGIMAG\n");
    printf("\n");
    printf("\n");
    printf("void cpgctab(const float *l, const float *r, const float *g, \\n");
    printf(" const float *b, int nc, float contra, float bright);\n");
    printf("\n");
    printf("      SUBROUTINE PGCTAB(L, R, G, B, NC, CONTRA, BRIGHT)\n");
    printf("      INTEGER NC\n");
    printf("      REAL    L(NC), R(NC), G(NC), B(NC), CONTRA, BRIGHT\n");
    printf("\n");
    printf("Use the given color table to change the color representations of\n");
    printf("all color indexes marked for use by PGIMAG <#PGIMAG>. To change which\n");
    printf("color indexes are thus marked, call PGSCIR <#PGSCIR> before calling PGCTAB <#PGCTAB>\n");
    printf("or PGIMAG <#PGIMAG>. On devices that can change the color representations\n");
    printf("of previously plotted graphics, PGCTAB <#PGCTAB> will also change the colors\n");
    printf("of existing graphics that were plotted with the marked color\n");
    printf("indexes. This feature can then be combined with PGBAND <#PGBAND> to\n");
    printf("interactively manipulate the displayed colors of data previously\n");
    printf("plotted with PGIMAG <#PGIMAG>.\n");
    printf("\n");
    printf("Limitations:\n");
    printf(" 1. Some devices do not propagate color representation changes\n");
    printf("    to previously drawn graphics.\n");
    printf(" 2. Some devices ignore requests to change color representations.\n");
    printf(" 3. The appearance of specific color representations on grey-scale\n");
    printf("    devices is device-dependent.\n");
    printf("\n");
    printf("Notes:\n");
    printf(" To reverse the sense of a color table, change the chosen contrast\n");
    printf(" and brightness to -CONTRA and 1-BRIGHT.\n");
    printf("\n");
    printf(" In the following, the term 'color table' refers to the input\n");
    printf(" L,R,G,B arrays, whereas 'color ramp' refers to the resulting\n");
    printf(" ramp of colors that would be seen with PGWEDG <#PGWEDG>.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" L      (input)  : An array of NC normalized ramp-intensity levels\n");
    printf("                   corresponding to the RGB primary color intensities\n");
    printf("                   in R(),G(),B(). Colors on the ramp are linearly\n");
    printf("                   interpolated from neighbouring levels.\n");
    printf("                   Levels must be sorted in increasing order.\n");
    printf("                    0.0 places a color at the beginning of the ramp.\n");
    printf("                    1.0 places a color at the end of the ramp.\n");
    printf("                   Colors outside these limits are legal, but will\n");
    printf("                   not be visible if CONTRA=1.0 and BRIGHT=0.5.\n");
    printf(" R      (input)  : An array of NC normalized red intensities.\n");
    printf(" G      (input)  : An array of NC normalized green intensities.\n");
    printf(" B      (input)  : An array of NC normalized blue intensities.\n");
    printf(" NC     (input)  : The number of color table entries.\n");
    printf(" CONTRA (input)  : The contrast of the color ramp (normally 1.0).\n");
    printf("                   Negative values reverse the direction of the ramp.\n");
    printf(" BRIGHT (input)  : The brightness of the color ramp. This is normally\n");
    printf("                   0.5, but can sensibly hold any value between 0.0\n");
    printf("                   and 1.0. Values at or beyond the latter two\n");
    printf("                   extremes, saturate the color ramp with the colors\n");
    printf("                   of the respective end of the color table.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGCURS") == 0) {
    printf("    PGCURS -- read cursor position\n");
    printf("\n");
    printf("\n");
    printf("int cpgcurs(float *x, float *y, char *ch_scalar);\n");
    printf("\n");
    printf("      INTEGER FUNCTION PGCURS (X, Y, CH)\n");
    printf("      REAL X, Y\n");
    printf("      CHARACTER*(*) CH\n");
    printf("\n");
    printf("Read the cursor position and a character typed by the user.\n");
    printf("The position is returned in world coordinates.  PGCURS <#PGCURS> positions\n");
    printf("the cursor at the position specified, allows the user to move the\n");
    printf("cursor using the joystick or arrow keys or whatever is available on\n");
    printf("the device. When he has positioned the cursor, the user types a\n");
    printf("single character on the keyboard; PGCURS <#PGCURS> then returns this\n");
    printf("character and the new cursor position (in world coordinates).\n");
    printf("\n");
    printf("Returns:\n");
    printf(" PGCURS <#PGCURS>         : 1 if the call was successful; 0 if the device\n");
    printf("                   has no cursor or some other error occurs.\n");
    printf("Arguments:\n");
    printf(" X      (in/out) : the world x-coordinate of the cursor.\n");
    printf(" Y      (in/out) : the world y-coordinate of the cursor.\n");
    printf(" CH     (output) : the character typed by the user; if the device has\n");
    printf("                   no cursor or if some other error occurs, the value\n");
    printf("                   CHAR(0) [ASCII NUL character] is returned.\n");
    printf("\n");
    printf("Note: The cursor coordinates (X,Y) may be changed by PGCURS <#PGCURS> even if\n");
    printf("the device has no cursor or if the user does not move the cursor.\n");
    printf("Under these circumstances, the position returned in (X,Y) is that of\n");
    printf("the pixel nearest to the requested position.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGDRAW") == 0) {
    printf("    PGDRAW -- draw a line from the current pen position to a point\n");
    printf("\n");
    printf("\n");
    printf("void cpgdraw(float x, float y);\n");
    printf("\n");
    printf("      SUBROUTINE PGDRAW (X, Y)\n");
    printf("      REAL X, Y\n");
    printf("\n");
    printf("Draw a line from the current pen position to the point\n");
    printf("with world-coordinates (X,Y). The line is clipped at the edge of the\n");
    printf("current window. The new pen position is (X,Y) in world coordinates.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X      (input)  : world x-coordinate of the end point of the line.\n");
    printf(" Y      (input)  : world y-coordinate of the end point of the line.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGEBUF") == 0) {
    printf("    PGEBUF -- end batch of output (buffer)\n");
    printf("\n");
    printf("\n");
    printf("void cpgebuf(void);\n");
    printf("\n");
    printf("      SUBROUTINE PGEBUF\n");
    printf("\n");
    printf("A call to PGEBUF <#PGEBUF> marks the end of a batch of graphical output begun\n");
    printf("with the last call of PGBBUF <#PGBBUF>.  PGBBUF and PGEBUF <#PGEBUF> calls should always\n");
    printf("be paired. Each call to PGBBUF <#PGBBUF> increments a counter, while each call\n");
    printf("to PGEBUF <#PGEBUF> decrements the counter. When the counter reaches 0, the\n");
    printf("batch of output is written on the output device.\n");
    printf("\n");
    printf("Arguments: none\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGEND") == 0) {
    printf("    PGEND -- close all open graphics devices\n");
    printf("\n");
    printf("\n");
    printf("void cpgend(void);\n");
    printf("\n");
    printf("      SUBROUTINE PGEND\n");
    printf("\n");
    printf("Close and release any open graphics devices. All devices must be\n");
    printf("closed by calling either PGCLOS <#PGCLOS> (for each device) or PGEND <#PGEND> before\n");
    printf("the program terminates. If a device is not closed properly, some\n");
    printf("or all of the graphical output may be lost.\n");
    printf("\n");
    printf("Arguments: none\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGENV") == 0) {
    printf("    PGENV -- set window and viewport and draw labeled frame\n");
    printf("\n");
    printf("\n");
    printf("void cpgenv(float xmin, float xmax, float ymin, float ymax, \\n");
    printf(" int just, int axis);\n");
    printf("\n");
    printf("      SUBROUTINE PGENV (XMIN, XMAX, YMIN, YMAX, JUST, AXIS)\n");
    printf("      REAL XMIN, XMAX, YMIN, YMAX\n");
    printf("      INTEGER JUST, AXIS\n");
    printf("\n");
    printf("Set PGPLOT \"Plotter Environment\".  PGENV <#PGENV> establishes the scaling\n");
    printf("for subsequent calls to PGPT <#PGPT>, PGLINE <#PGLINE>, etc.  The plotter is\n");
    printf("advanced to a new page or panel, clearing the screen if necessary.\n");
    printf("If the \"prompt state\" is ON (see PGASK <#PGASK>), confirmation\n");
    printf("is requested from the user before clearing the screen.\n");
    printf("If requested, a box, axes, labels, etc. are drawn according to\n");
    printf("the setting of argument AXIS.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" XMIN   (input)  : the world x-coordinate at the bottom left corner\n");
    printf("                   of the viewport.\n");
    printf(" XMAX   (input)  : the world x-coordinate at the top right corner\n");
    printf("                   of the viewport (note XMAX may be less than XMIN).\n");
    printf(" YMIN   (input)  : the world y-coordinate at the bottom left corner\n");
    printf("                   of the viewport.\n");
    printf(" YMAX   (input)  : the world y-coordinate at the top right corner\n");
    printf("                   of the viewport (note YMAX may be less than YMIN).\n");
    printf(" JUST   (input)  : if JUST=1, the scales of the x and y axes (in\n");
    printf("                   world coordinates per inch) will be equal,\n");
    printf("                   otherwise they will be scaled independently.\n");
    printf(" AXIS   (input)  : controls the plotting of axes, tick marks, etc:\n");
    printf("     AXIS = -2 : draw no box, axes or labels;\n");
    printf("     AXIS = -1 : draw box only;\n");
    printf("     AXIS =  0 : draw box and label it with coordinates;\n");
    printf("     AXIS =  1 : same as AXIS=0, but also draw the\n");
    printf("                 coordinate axes (X=0, Y=0);\n");
    printf("     AXIS =  2 : same as AXIS=1, but also draw grid lines\n");
    printf("                 at major increments of the coordinates;\n");
    printf("     AXIS = 10 : draw box and label X-axis logarithmically;\n");
    printf("     AXIS = 20 : draw box and label Y-axis logarithmically;\n");
    printf("     AXIS = 30 : draw box and label both axes logarithmically.\n");
    printf("\n");
    printf("For other axis options, use routine PGBOX <#PGBOX>. PGENV <#PGENV> can be persuaded to\n");
    printf("call PGBOX <#PGBOX> with additional axis options by defining an environment\n");
    printf("parameter PGPLOT_ENVOPT containing the required option codes. \n");
    printf("Examples:\n");
    printf("  PGPLOT_ENVOPT=P      ! draw Projecting tick marks\n");
    printf("  PGPLOT_ENVOPT=I      ! Invert the tick marks\n");
    printf("  PGPLOT_ENVOPT=IV     ! Invert tick marks and label y Vertically\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGERAS") == 0) {
    printf("    PGERAS -- erase all graphics from current page\n");
    printf("\n");
    printf("\n");
    printf("void cpgeras(void);\n");
    printf("\n");
    printf("      SUBROUTINE PGERAS\n");
    printf("\n");
    printf("Erase all graphics from the current page (or current panel, if\n");
    printf("the view surface has been divided into panels with PGSUBP <#PGSUBP>).\n");
    printf("\n");
    printf("Arguments: none\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGERR1") == 0) {
    printf("    PGERR1 -- horizontal or vertical error bar\n");
    printf("\n");
    printf("\n");
    printf("void cpgerr1(int dir, float x, float y, float e, float t);\n");
    printf("\n");
    printf("      SUBROUTINE PGERR1 (DIR, X, Y, E, T)\n");
    printf("      INTEGER DIR\n");
    printf("      REAL X, Y, E\n");
    printf("      REAL T\n");
    printf("\n");
    printf("Plot a single error bar in the direction specified by DIR.\n");
    printf("This routine draws an error bar only; to mark the data point at\n");
    printf("the start of the error bar, an additional call to PGPT <#PGPT> is required.\n");
    printf("To plot many error bars, use PGERRB <#PGERRB>.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" DIR    (input)  : direction to plot the error bar relative to\n");
    printf("                   the data point. \n");
    printf("                   One-sided error bar:\n");
    printf("                     DIR is 1 for +X (X to X+E);\n");
    printf("                            2 for +Y (Y to Y+E);\n");
    printf("                            3 for -X (X to X-E);\n");
    printf("                            4 for -Y (Y to Y-E).\n");
    printf("                   Two-sided error bar:\n");
    printf("                     DIR is 5 for +/-X (X-E to X+E); \n");
    printf("                            6 for +/-Y (Y-E to Y+E).\n");
    printf(" X      (input)  : world x-coordinate of the data.\n");
    printf(" Y      (input)  : world y-coordinate of the data.\n");
    printf(" E      (input)  : value of error bar distance to be added to the\n");
    printf("                   data position in world coordinates.\n");
    printf(" T      (input)  : length of terminals to be drawn at the ends\n");
    printf("                   of the error bar, as a multiple of the default\n");
    printf("                   length; if T = 0.0, no terminals will be drawn.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGERRB") == 0) {
    printf("    PGERRB -- horizontal or vertical error bar\n");
    printf("\n");
    printf("\n");
    printf("void cpgerrb(int dir, int n, const float *x, const float *y, \\n");
    printf(" const float *e, float t);\n");
    printf("\n");
    printf("      SUBROUTINE PGERRB (DIR, N, X, Y, E, T)\n");
    printf("      INTEGER DIR, N\n");
    printf("      REAL X(*), Y(*), E(*)\n");
    printf("      REAL T\n");
    printf("\n");
    printf("Plot error bars in the direction specified by DIR.\n");
    printf("This routine draws an error bar only; to mark the data point at\n");
    printf("the start of the error bar, an additional call to PGPT <#PGPT> is required.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" DIR    (input)  : direction to plot the error bar relative to\n");
    printf("                   the data point. \n");
    printf("                   One-sided error bar:\n");
    printf("                     DIR is 1 for +X (X to X+E);\n");
    printf("                            2 for +Y (Y to Y+E);\n");
    printf("                            3 for -X (X to X-E);\n");
    printf("                            4 for -Y (Y to Y-E).\n");
    printf("                   Two-sided error bar:\n");
    printf("                     DIR is 5 for +/-X (X-E to X+E); \n");
    printf("                            6 for +/-Y (Y-E to Y+E).\n");
    printf(" N      (input)  : number of error bars to plot.\n");
    printf(" X      (input)  : world x-coordinates of the data.\n");
    printf(" Y      (input)  : world y-coordinates of the data.\n");
    printf(" E      (input)  : value of error bar distance to be added to the\n");
    printf("                   data position in world coordinates.\n");
    printf(" T      (input)  : length of terminals to be drawn at the ends\n");
    printf("                   of the error bar, as a multiple of the default\n");
    printf("                   length; if T = 0.0, no terminals will be drawn.\n");
    printf("\n");
    printf("Note: the dimension of arrays X, Y, and E must be greater\n");
    printf("than or equal to N. If N is 1, X, Y, and E may be scalar\n");
    printf("variables, or expressions.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGERRX") == 0) {
    printf("    PGERRX -- horizontal error bar\n");
    printf("\n");
    printf("\n");
    printf("void cpgerrx(int n, const float *x1, const float *x2, \\n");
    printf(" const float *y, float t);\n");
    printf("\n");
    printf("      SUBROUTINE PGERRX (N, X1, X2, Y, T)\n");
    printf("      INTEGER N\n");
    printf("      REAL X1(*), X2(*), Y(*)\n");
    printf("      REAL T\n");
    printf("\n");
    printf("Plot horizontal error bars.\n");
    printf("This routine draws an error bar only; to mark the data point in\n");
    printf("the middle of the error bar, an additional call to PGPT <#PGPT> or\n");
    printf("PGERRY <#PGERRY> is required.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" N      (input)  : number of error bars to plot.\n");
    printf(" X1     (input)  : world x-coordinates of lower end of the\n");
    printf("                   error bars.\n");
    printf(" X2     (input)  : world x-coordinates of upper end of the\n");
    printf("                   error bars.\n");
    printf(" Y      (input)  : world y-coordinates of the data.\n");
    printf(" T      (input)  : length of terminals to be drawn at the ends\n");
    printf("                   of the error bar, as a multiple of the default\n");
    printf("                   length; if T = 0.0, no terminals will be drawn.\n");
    printf("\n");
    printf("Note: the dimension of arrays X1, X2, and Y must be greater\n");
    printf("than or equal to N. If N is 1, X1, X2, and Y may be scalar\n");
    printf("variables, or expressions, eg:\n");
    printf("      CALL PGERRX <#PGERRX>(1,X-SIGMA,X+SIGMA,Y)\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGERRY") == 0) {
    printf("    PGERRY -- vertical error bar\n");
    printf("\n");
    printf("\n");
    printf("void cpgerry(int n, const float *x, const float *y1, \\n");
    printf(" const float *y2, float t);\n");
    printf("\n");
    printf("      SUBROUTINE PGERRY (N, X, Y1, Y2, T)\n");
    printf("      INTEGER N\n");
    printf("      REAL X(*), Y1(*), Y2(*)\n");
    printf("      REAL T\n");
    printf("\n");
    printf("Plot vertical error bars.\n");
    printf("This routine draws an error bar only; to mark the data point in\n");
    printf("the middle of the error bar, an additional call to PGPT <#PGPT> or\n");
    printf("PGERRX <#PGERRX> is required.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" N      (input)  : number of error bars to plot.\n");
    printf(" X      (input)  : world x-coordinates of the data.\n");
    printf(" Y1     (input)  : world y-coordinates of top end of the\n");
    printf("                   error bars.\n");
    printf(" Y2     (input)  : world y-coordinates of bottom end of the\n");
    printf("                   error bars.\n");
    printf(" T      (input)  : length of terminals to be drawn at the ends\n");
    printf("                   of the error bar, as a multiple of the default\n");
    printf("                   length; if T = 0.0, no terminals will be drawn.\n");
    printf("\n");
    printf("Note: the dimension of arrays X, Y1, and Y2 must be greater\n");
    printf("than or equal to N. If N is 1, X, Y1, and Y2 may be scalar\n");
    printf("variables or expressions, eg:\n");
    printf("      CALL PGERRY <#PGERRY>(1,X,Y+SIGMA,Y-SIGMA)\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGETXT") == 0) {
    printf("    PGETXT -- erase text from graphics display\n");
    printf("\n");
    printf("\n");
    printf("void cpgetxt(void);\n");
    printf("\n");
    printf("      SUBROUTINE PGETXT\n");
    printf("\n");
    printf("Some graphics terminals display text (the normal interactive dialog)\n");
    printf("on the same screen as graphics. This routine erases the text from the\n");
    printf("view surface without affecting the graphics. It does nothing on\n");
    printf("devices which do not display text on the graphics screen, and on\n");
    printf("devices which do not have this capability.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" None\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGFUNT") == 0) {
    printf("    PGFUNT -- function defined by X = F(T), Y = G(T)\n");
    printf("\n");
    printf("      SUBROUTINE PGFUNT (FX, FY, N, TMIN, TMAX, PGFLAG)\n");
    printf("      REAL FX, FY\n");
    printf("      EXTERNAL FX, FY\n");
    printf("      INTEGER N\n");
    printf("      REAL TMIN, TMAX\n");
    printf("      INTEGER PGFLAG\n");
    printf("\n");
    printf("Draw a curve defined by parametric equations X = FX(T), Y = FY(T).\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" FX     (external real function): supplied by the user, evaluates\n");
    printf("                   X-coordinate.\n");
    printf(" FY     (external real function): supplied by the user, evaluates\n");
    printf("                   Y-coordinate.\n");
    printf(" N      (input)  : the number of points required to define the\n");
    printf("                   curve. The functions FX and FY will each be\n");
    printf("                   called N+1 times.\n");
    printf(" TMIN   (input)  : the minimum value for the parameter T.\n");
    printf(" TMAX   (input)  : the maximum value for the parameter T.\n");
    printf(" PGFLAG (input)  : if PGFLAG = 1, the curve is plotted in the\n");
    printf("                   current window and viewport; if PGFLAG = 0,\n");
    printf("                   PGENV <#PGENV> is called automatically by PGFUNT <#PGFUNT> to\n");
    printf("                   start a new plot with automatic scaling.\n");
    printf("\n");
    printf("Note: The functions FX and FY must be declared EXTERNAL in the\n");
    printf("Fortran program unit that calls PGFUNT <#PGFUNT>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGFUNX") == 0) {
    printf("    PGFUNX -- function defined by Y = F(X)\n");
    printf("\n");
    printf("      SUBROUTINE PGFUNX (FY, N, XMIN, XMAX, PGFLAG)\n");
    printf("      REAL FY\n");
    printf("      EXTERNAL FY\n");
    printf("      INTEGER N\n");
    printf("      REAL XMIN, XMAX\n");
    printf("      INTEGER PGFLAG\n");
    printf("\n");
    printf("Draw a curve defined by the equation Y = FY(X), where FY is a\n");
    printf("user-supplied subroutine.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" FY     (external real function): supplied by the user, evaluates\n");
    printf("                   Y value at a given X-coordinate.\n");
    printf(" N      (input)  : the number of points required to define the\n");
    printf("                   curve. The function FY will be called N+1 times.\n");
    printf("                   If PGFLAG=0 and N is greater than 1000, 1000\n");
    printf("                   will be used instead.  If N is less than 1,\n");
    printf("                   nothing will be drawn.\n");
    printf(" XMIN   (input)  : the minimum value of X.\n");
    printf(" XMAX   (input)  : the maximum value of X.\n");
    printf(" PGFLAG (input)  : if PGFLAG = 1, the curve is plotted in the\n");
    printf("                   current window and viewport; if PGFLAG = 0,\n");
    printf("                   PGENV <#PGENV> is called automatically by PGFUNX <#PGFUNX> to\n");
    printf("                   start a new plot with X limits (XMIN, XMAX)\n");
    printf("                   and automatic scaling in Y.\n");
    printf("\n");
    printf("Note: The function FY must be declared EXTERNAL in the Fortran\n");
    printf("program unit that calls PGFUNX <#PGFUNX>.  It has one argument, the\n");
    printf("x-coordinate at which the y value is required, e.g.\n");
    printf("  REAL FUNCTION FY(X)\n");
    printf("  REAL X\n");
    printf("  FY = .....\n");
    printf("  END\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGFUNY") == 0) {
    printf("    PGFUNY -- function defined by X = F(Y)\n");
    printf("\n");
    printf("      SUBROUTINE PGFUNY (FX, N, YMIN, YMAX, PGFLAG)\n");
    printf("      REAL    FX\n");
    printf("      EXTERNAL FX\n");
    printf("      INTEGER N\n");
    printf("      REAL    YMIN, YMAX\n");
    printf("      INTEGER PGFLAG\n");
    printf("\n");
    printf("Draw a curve defined by the equation X = FX(Y), where FY is a\n");
    printf("user-supplied subroutine.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" FX     (external real function): supplied by the user, evaluates\n");
    printf("                   X value at a given Y-coordinate.\n");
    printf(" N      (input)  : the number of points required to define the\n");
    printf("                   curve. The function FX will be called N+1 times.\n");
    printf("                   If PGFLAG=0 and N is greater than 1000, 1000\n");
    printf("                   will be used instead.  If N is less than 1,\n");
    printf("                   nothing will be drawn.\n");
    printf(" YMIN   (input)  : the minimum value of Y.\n");
    printf(" YMAX   (input)  : the maximum value of Y.\n");
    printf(" PGFLAG (input)  : if PGFLAG = 1, the curve is plotted in the\n");
    printf("                   current window and viewport; if PGFLAG = 0,\n");
    printf("                   PGENV <#PGENV> is called automatically by PGFUNY <#PGFUNY> to\n");
    printf("                   start a new plot with Y limits (YMIN, YMAX)\n");
    printf("                   and automatic scaling in X.\n");
    printf("\n");
    printf("Note: The function FX must be declared EXTERNAL in the Fortran\n");
    printf("program unit that calls PGFUNY <#PGFUNY>.  It has one argument, the\n");
    printf("y-coordinate at which the x value is required, e.g.\n");
    printf("  REAL FUNCTION FX(Y)\n");
    printf("  REAL Y\n");
    printf("  FX = .....\n");
    printf("  END\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGGRAY") == 0) {
    printf("    PGGRAY -- gray-scale map of a 2D data array\n");
    printf("\n");
    printf("\n");
    printf("void cpggray(const float *a, int idim, int jdim, int i1, int i2, \\n");
    printf(" int j1, int j2, float fg, float bg, const float *tr);\n");
    printf("\n");
    printf("      SUBROUTINE PGGRAY (A, IDIM, JDIM, I1, I2, J1, J2,\n");
    printf("     1                   FG, BG, TR)\n");
    printf("      INTEGER IDIM, JDIM, I1, I2, J1, J2\n");
    printf("      REAL    A(IDIM,JDIM), FG, BG, TR(6)\n");
    printf("\n");
    printf("Draw gray-scale map of an array in current window. The subsection\n");
    printf("of the array A defined by indices (I1:I2, J1:J2) is mapped onto\n");
    printf("the view surface world-coordinate system by the transformation\n");
    printf("matrix TR. The resulting quadrilateral region is clipped at the edge\n");
    printf("of the window and shaded with the shade at each point determined\n");
    printf("by the corresponding array value.  The shade is a number in the\n");
    printf("range 0 to 1 obtained by linear interpolation between the background\n");
    printf("level (BG) and the foreground level (FG), i.e.,\n");
    printf("\n");
    printf("  shade = [A(i,j) - BG] / [FG - BG]\n");
    printf("\n");
    printf("The background level BG can be either less than or greater than the\n");
    printf("foreground level FG.  Points in the array that are outside the range\n");
    printf("BG to FG are assigned shade 0 or 1 as appropriate.\n");
    printf("\n");
    printf("PGGRAY <#PGGRAY> uses two different algorithms, depending how many color\n");
    printf("indices are available in the color index range specified for images.\n");
    printf("(This range is set with routine PGSCIR <#PGSCIR>, and the current or default\n");
    printf("range can be queried by calling routine PGQCIR <#PGQCIR>).\n");
    printf("\n");
    printf("If 16 or more color indices are available, PGGRAY <#PGGRAY> first assigns\n");
    printf("color representations to these color indices to give a linear ramp\n");
    printf("between the background color (color index 0) and the foreground color\n");
    printf("(color index 1), and then calls PGIMAG <#PGIMAG> to draw the image using these\n");
    printf("color indices. In this mode, the shaded region is \"opaque\": every\n");
    printf("pixel is assigned a color.\n");
    printf("\n");
    printf("If less than 16 color indices are available, PGGRAY <#PGGRAY> uses only\n");
    printf("color index 1, and uses  a \"dithering\" algorithm to fill in pixels,\n");
    printf("with the shade (computed as above) determining the faction of pixels\n");
    printf("that are filled. In this mode the shaded region is \"transparent\" and\n");
    printf("allows previously-drawn graphics to show through.\n");
    printf("\n");
    printf("The transformation matrix TR is used to calculate the world\n");
    printf("coordinates of the center of the \"cell\" that represents each\n");
    printf("array element. The world coordinates of the center of the cell\n");
    printf("corresponding to array element A(I,J) are given by:\n");
    printf("\n");
    printf("         X = TR(1) + TR(2)*I + TR(3)*J\n");
    printf("         Y = TR(4) + TR(5)*I + TR(6)*J\n");
    printf("\n");
    printf("Usually TR(3) and TR(5) are zero -- unless the coordinate\n");
    printf("transformation involves a rotation or shear.  The corners of the\n");
    printf("quadrilateral region that is shaded by PGGRAY <#PGGRAY> are given by\n");
    printf("applying this transformation to (I1-0.5,J1-0.5), (I2+0.5, J2+0.5).\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" A      (input)  : the array to be plotted.\n");
    printf(" IDIM   (input)  : the first dimension of array A.\n");
    printf(" JDIM   (input)  : the second dimension of array A.\n");
    printf(" I1, I2 (input)  : the inclusive range of the first index\n");
    printf("                   (I) to be plotted.\n");
    printf(" J1, J2 (input)  : the inclusive range of the second\n");
    printf("                   index (J) to be plotted.\n");
    printf(" FG     (input)  : the array value which is to appear with the\n");
    printf("                   foreground color (corresponding to color index 1).\n");
    printf(" BG     (input)  : the array value which is to appear with the\n");
    printf("                   background color (corresponding to color index 0).\n");
    printf(" TR     (input)  : transformation matrix between array grid and\n");
    printf("                   world coordinates.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGHI2D") == 0) {
    printf("    PGHI2D -- cross-sections through a 2D data array\n");
    printf("\n");
    printf("\n");
    printf("void cpghi2d(const float *data, int nxv, int nyv, int ix1, \\n");
    printf(" int ix2, int iy1, int iy2, const float *x, int ioff, float bias, \\n");
    printf(" Logical center, float *ylims);\n");
    printf("\n");
    printf("      SUBROUTINE PGHI2D (DATA, NXV, NYV, IX1, IX2, IY1, IY2, X, IOFF,\n");
    printf("     1                   BIAS, CENTER, YLIMS)\n");
    printf("      INTEGER NXV, NYV, IX1, IX2, IY1, IY2\n");
    printf("      REAL    DATA(NXV,NYV)\n");
    printf("      REAL    X(IX2-IX1+1), YLIMS(IX2-IX1+1)\n");
    printf("      INTEGER IOFF\n");
    printf("      REAL    BIAS\n");
    printf("      LOGICAL CENTER\n");
    printf("\n");
    printf("Plot a series of cross-sections through a 2D data array.\n");
    printf("Each cross-section is plotted as a hidden line histogram.  The plot\n");
    printf("can be slanted to give a pseudo-3D effect - if this is done, the\n");
    printf("call to PGENV <#PGENV> may have to be changed to allow for the increased X\n");
    printf("range that will be needed.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" DATA   (input)  : the data array to be plotted.\n");
    printf(" NXV    (input)  : the first dimension of DATA.\n");
    printf(" NYV    (input)  : the second dimension of DATA.\n");
    printf(" IX1    (input)\n");
    printf(" IX2    (input)\n");
    printf(" IY1    (input)\n");
    printf(" IY2    (input)  : PGHI2D <#PGHI2D> plots a subset of the input array DATA.\n");
    printf("                   This subset is delimited in the first (x)\n");
    printf("                   dimension by IX1 and IX2 and the 2nd (y) by IY1\n");
    printf("                   and IY2, inclusively. Note: IY2 < IY1 is\n");
    printf("                   permitted, resulting in a plot with the\n");
    printf("                   cross-sections plotted in reverse Y order.\n");
    printf("                   However, IX2 must be => IX1.\n");
    printf(" X      (input)  : the abscissae of the bins to be plotted. That is,\n");
    printf("                   X(1) should be the X value for DATA(IX1,IY1), and\n");
    printf("                   X should have (IX2-IX1+1) elements.  The program\n");
    printf("                   has to assume that the X value for DATA(x,y) is\n");
    printf("                   the same for all y.\n");
    printf(" IOFF   (input)  : an offset in array elements applied to successive\n");
    printf("                   cross-sections to produce a slanted effect.  A\n");
    printf("                   plot with IOFF > 0 slants to the right, one with\n");
    printf("                   IOFF < 0 slants left.\n");
    printf(" BIAS   (input)  : a bias value applied to each successive cross-\n");
    printf("                   section in order to raise it above the previous\n");
    printf("                   cross-section.  This is in the same units as the\n");
    printf("                   data.\n");
    printf(" CENTER (input)  : if .true., the X values denote the center of the\n");
    printf("                   bins; if .false. the X values denote the lower\n");
    printf("                   edges (in X) of the bins.\n");
    printf(" YLIMS  (input)  : workspace.  Should be an array of at least\n");
    printf("                   (IX2-IX1+1) elements.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGHIST") == 0) {
    printf("    PGHIST -- histogram of unbinned data\n");
    printf("\n");
    printf("\n");
    printf("void cpghist(int n, const float *data, float datmin, float datmax, \\n");
    printf(" int nbin, int pgflag);\n");
    printf("\n");
    printf("      SUBROUTINE PGHIST(N, DATA, DATMIN, DATMAX, NBIN, PGFLAG)\n");
    printf("      INTEGER N\n");
    printf("      REAL    DATA(*)\n");
    printf("      REAL    DATMIN, DATMAX\n");
    printf("      INTEGER NBIN, PGFLAG\n");
    printf("\n");
    printf("Draw a histogram of N values of a variable in array\n");
    printf("DATA(1...N) in the range DATMIN to DATMAX using NBIN bins.  Note\n");
    printf("that array elements which fall exactly on the boundary between\n");
    printf("two bins will be counted in the higher bin rather than the\n");
    printf("lower one; and array elements whose value is less than DATMIN or\n");
    printf("greater than or equal to DATMAX will not be counted at all.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" N      (input)  : the number of data values.\n");
    printf(" DATA   (input)  : the data values. Note: the dimension of array\n");
    printf("                   DATA must be greater than or equal to N. The\n");
    printf("                   first N elements of the array are used.\n");
    printf(" DATMIN (input)  : the minimum data value for the histogram.\n");
    printf(" DATMAX (input)  : the maximum data value for the histogram.\n");
    printf(" NBIN   (input)  : the number of bins to use: the range DATMIN to\n");
    printf("                   DATMAX is divided into NBIN equal bins and\n");
    printf("                   the number of DATA values in each bin is\n");
    printf("                   determined by PGHIST <#PGHIST>.  NBIN may not exceed 200.\n");
    printf(" PGFLAG (input)  : if PGFLAG = 1, the histogram is plotted in the\n");
    printf("                   current window and viewport; if PGFLAG = 0,\n");
    printf("                   PGENV <#PGENV> is called automatically by PGHIST <#PGHIST> to start\n");
    printf("                   a new plot (the x-limits of the window will be\n");
    printf("                   DATMIN and DATMAX; the y-limits will be chosen\n");
    printf("                   automatically.\n");
    printf("                   IF PGFLAG = 2,3 the histogram will be in the same\n");
    printf("                   window and viewport but with a filled area style.\n");
    printf("                   If pgflag=4,5 as for pgflag = 0,1, but simple\n");
    printf("                   line drawn as for PGBIN <#PGBIN>\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGIDEN") == 0) {
    printf("    PGIDEN -- write username, date, and time at bottom of plot\n");
    printf("\n");
    printf("\n");
    printf("void cpgiden(void);\n");
    printf("\n");
    printf("      SUBROUTINE PGIDEN\n");
    printf("\n");
    printf("Write username, date, and time at bottom of plot.\n");
    printf("\n");
    printf("Arguments: none.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGIMAG") == 0) {
    printf("    PGIMAG -- color image from a 2D data array\n");
    printf("\n");
    printf("\n");
    printf("void cpgimag(const float *a, int idim, int jdim, int i1, int i2, \\n");
    printf(" int j1, int j2, float a1, float a2, const float *tr);\n");
    printf("\n");
    printf("      SUBROUTINE PGIMAG (A, IDIM, JDIM, I1, I2, J1, J2,\n");
    printf("     1                   A1, A2, TR)\n");
    printf("      INTEGER IDIM, JDIM, I1, I2, J1, J2\n");
    printf("      REAL    A(IDIM,JDIM), A1, A2, TR(6)\n");
    printf("\n");
    printf("Draw a color image of an array in current window. The subsection\n");
    printf("of the array A defined by indices (I1:I2, J1:J2) is mapped onto\n");
    printf("the view surface world-coordinate system by the transformation\n");
    printf("matrix TR. The resulting quadrilateral region is clipped at the edge\n");
    printf("of the window. Each element of the array is represented in the image\n");
    printf("by a small quadrilateral, which is filled with a color specified by\n");
    printf("the corresponding array value.\n");
    printf("\n");
    printf("The subroutine uses color indices in the range C1 to C2, which can\n");
    printf("be specified by calling PGSCIR <#PGSCIR> before PGIMAG <#PGIMAG>. The default values\n");
    printf("for C1 and C2 are device-dependent; these values can be determined by\n");
    printf("calling PGQCIR <#PGQCIR>. Note that color representations should be assigned to\n");
    printf("color indices C1 to C2 by calling PGSCR <#PGSCR> before calling PGIMAG <#PGIMAG>. On some\n");
    printf("devices (but not all), the color representation can be changed after\n");
    printf("the call to PGIMAG <#PGIMAG> by calling PGSCR <#PGSCR> again.\n");
    printf("\n");
    printf("Array values in the range A1 to A2 are mapped on to the range of\n");
    printf("color indices C1 to C2, with array values <= A1 being given color\n");
    printf("index C1 and values >= A2 being given color index C2. The mapping\n");
    printf("function for intermediate array values can be specified by\n");
    printf("calling routine PGSITF <#PGSITF> before PGIMAG <#PGIMAG>; the default is linear.\n");
    printf("\n");
    printf("On devices which have no available color indices (C1 > C2),\n");
    printf("PGIMAG <#PGIMAG> will return without doing anything. On devices with only\n");
    printf("one color index (C1=C2), all array values map to the same color\n");
    printf("which is rather uninteresting. An image is always \"opaque\",\n");
    printf("i.e., it obscures all graphical elements previously drawn in\n");
    printf("the region.\n");
    printf("\n");
    printf("The transformation matrix TR is used to calculate the world\n");
    printf("coordinates of the center of the \"cell\" that represents each\n");
    printf("array element. The world coordinates of the center of the cell\n");
    printf("corresponding to array element A(I,J) are given by:\n");
    printf("\n");
    printf("         X = TR(1) + TR(2)*I + TR(3)*J\n");
    printf("         Y = TR(4) + TR(5)*I + TR(6)*J\n");
    printf("\n");
    printf("Usually TR(3) and TR(5) are zero -- unless the coordinate\n");
    printf("transformation involves a rotation or shear.  The corners of the\n");
    printf("quadrilateral region that is shaded by PGIMAG <#PGIMAG> are given by\n");
    printf("applying this transformation to (I1-0.5,J1-0.5), (I2+0.5, J2+0.5).\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" A      (input)  : the array to be plotted.\n");
    printf(" IDIM   (input)  : the first dimension of array A.\n");
    printf(" JDIM   (input)  : the second dimension of array A.\n");
    printf(" I1, I2 (input)  : the inclusive range of the first index\n");
    printf("                   (I) to be plotted.\n");
    printf(" J1, J2 (input)  : the inclusive range of the second\n");
    printf("                   index (J) to be plotted.\n");
    printf(" A1     (input)  : the array value which is to appear with shade C1.\n");
    printf(" A2     (input)  : the array value which is to appear with shade C2.\n");
    printf(" TR     (input)  : transformation matrix between array grid and\n");
    printf("                   world coordinates.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGLAB") == 0) {
    printf("    PGLAB -- write labels for x-axis, y-axis, and top of plot\n");
    printf("\n");
    printf("\n");
    printf("void cpglab(const char *xlbl, const char *ylbl, const char *toplbl);\n");
    printf("\n");
    printf("      SUBROUTINE PGLAB (XLBL, YLBL, TOPLBL)\n");
    printf("      CHARACTER*(*) XLBL, YLBL, TOPLBL\n");
    printf("\n");
    printf("Write labels outside the viewport. This routine is a simple\n");
    printf("interface to PGMTXT <#PGMTXT>, which should be used if PGLAB <#PGLAB> is inadequate.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" XLBL   (input) : a label for the x-axis (centered below the\n");
    printf("                  viewport).\n");
    printf(" YLBL   (input) : a label for the y-axis (centered to the left\n");
    printf("                  of the viewport, drawn vertically).\n");
    printf(" TOPLBL (input) : a label for the entire plot (centered above the\n");
    printf("                  viewport).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGLCUR") == 0) {
    printf("    PGLCUR -- draw a line using the cursor\n");
    printf("\n");
    printf("\n");
    printf("void cpglcur(int maxpt, int *npt, float *x, float *y);\n");
    printf("\n");
    printf("      SUBROUTINE PGLCUR (MAXPT, NPT, X, Y)\n");
    printf("      INTEGER MAXPT, NPT\n");
    printf("      REAL    X(*), Y(*)\n");
    printf("\n");
    printf("Interactive routine for user to enter a polyline by use of\n");
    printf("the cursor.  Routine allows user to Add and Delete vertices;\n");
    printf("vertices are joined by straight-line segments.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" MAXPT  (input)  : maximum number of points that may be accepted.\n");
    printf(" NPT    (in/out) : number of points entered; should be zero on\n");
    printf("                   first call.\n");
    printf(" X      (in/out) : array of x-coordinates (dimension at least MAXPT).\n");
    printf(" Y      (in/out) : array of y-coordinates (dimension at least MAXPT).\n");
    printf("\n");
    printf("Notes:\n");
    printf("\n");
    printf("(1) On return from the program, cursor points are returned in\n");
    printf("the order they were entered. Routine may be (re-)called with points\n");
    printf("already defined in X,Y (# in NPT), and they will be plotted\n");
    printf("first, before editing.\n");
    printf("\n");
    printf("(2) User commands: the user types single-character commands\n");
    printf("after positioning the cursor: the following are accepted:\n");
    printf("  A (Add)    - add point at current cursor location.\n");
    printf("  D (Delete) - delete last-entered point.\n");
    printf("  X (eXit)   - leave subroutine.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGLDEV") == 0) {
    printf("    PGLDEV -- list available device types on standard output\n");
    printf("\n");
    printf("\n");
    printf("void cpgldev(void);\n");
    printf("\n");
    printf("      SUBROUTINE PGLDEV\n");
    printf("\n");
    printf("Writes (to standard output) a list of all device types available in\n");
    printf("the current PGPLOT installation.\n");
    printf("\n");
    printf("Arguments: none.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGLEN") == 0) {
    printf("    PGLEN -- find length of a string in a variety of units\n");
    printf("\n");
    printf("\n");
    printf("void cpglen(int units, const char *string, float *xl, float *yl);\n");
    printf("\n");
    printf("      SUBROUTINE PGLEN (UNITS, STRING, XL, YL)\n");
    printf("      REAL XL, YL\n");
    printf("      INTEGER UNITS\n");
    printf("      CHARACTER*(*) STRING\n");
    printf("\n");
    printf("Work out length of a string in x and y directions \n");
    printf("\n");
    printf("Input\n");
    printf(" UNITS    :  0 => answer in normalized device coordinates\n");
    printf("             1 => answer in inches\n");
    printf("             2 => answer in mm\n");
    printf("             3 => answer in absolute device coordinates (dots)\n");
    printf("             4 => answer in world coordinates\n");
    printf("             5 => answer as a fraction of the current viewport size\n");
    printf("\n");
    printf(" STRING   :  String of interest\n");
    printf("Output\n");
    printf(" XL       :  Length of string in x direction\n");
    printf(" YL       :  Length of string in y direction\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGLINE") == 0) {
    printf("    PGLINE -- draw a polyline (curve defined by line-segments)\n");
    printf("\n");
    printf("\n");
    printf("void cpgline(int n, const float *xpts, const float *ypts);\n");
    printf("\n");
    printf("      SUBROUTINE PGLINE (N, XPTS, YPTS)\n");
    printf("      INTEGER  N\n");
    printf("      REAL     XPTS(*), YPTS(*)\n");
    printf("\n");
    printf("Primitive routine to draw a Polyline. A polyline is one or more\n");
    printf("connected straight-line segments.  The polyline is drawn using\n");
    printf("the current setting of attributes color-index, line-style, and\n");
    printf("line-width. The polyline is clipped at the edge of the window.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" N      (input)  : number of points defining the line; the line\n");
    printf("                   consists of (N-1) straight-line segments.\n");
    printf("                   N should be greater than 1 (if it is 1 or less,\n");
    printf("                   nothing will be drawn).\n");
    printf(" XPTS   (input)  : world x-coordinates of the points.\n");
    printf(" YPTS   (input)  : world y-coordinates of the points.\n");
    printf("\n");
    printf("The dimension of arrays X and Y must be greater than or equal to N.\n");
    printf("The \"pen position\" is changed to (X(N),Y(N)) in world coordinates\n");
    printf("(if N > 1).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGMOVE") == 0) {
    printf("    PGMOVE -- move pen (change current pen position)\n");
    printf("\n");
    printf("\n");
    printf("void cpgmove(float x, float y);\n");
    printf("\n");
    printf("      SUBROUTINE PGMOVE (X, Y)\n");
    printf("      REAL X, Y\n");
    printf("\n");
    printf("Primitive routine to move the \"pen\" to the point with world\n");
    printf("coordinates (X,Y). No line is drawn.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X      (input)  : world x-coordinate of the new pen position.\n");
    printf(" Y      (input)  : world y-coordinate of the new pen position.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGMTXT") == 0) {
    printf("    PGMTXT -- write text at position relative to viewport\n");
    printf("\n");
    printf("\n");
    printf("void cpgmtxt(const char *side, float disp, float coord, \\n");
    printf(" float fjust, const char *text);\n");
    printf("\n");
    printf("      SUBROUTINE PGMTXT (SIDE, DISP, COORD, FJUST, TEXT)\n");
    printf("      CHARACTER*(*) SIDE, TEXT\n");
    printf("      REAL DISP, COORD, FJUST\n");
    printf("\n");
    printf("Write text at a position specified relative to the viewport (outside\n");
    printf("or inside).  This routine is useful for annotating graphs. It is used\n");
    printf("by routine PGLAB <#PGLAB>.  The text is written using the current values of\n");
    printf("attributes color-index, line-width, character-height, and\n");
    printf("character-font.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" SIDE   (input)  : must include one of the characters 'B', 'L', 'T',\n");
    printf("                   or 'R' signifying the Bottom, Left, Top, or Right\n");
    printf("                   margin of the viewport. If it includes 'LV' or\n");
    printf("                   'RV', the string is written perpendicular to the\n");
    printf("                   frame rather than parallel to it.\n");
    printf(" DISP   (input)  : the displacement of the character string from the\n");
    printf("                   specified edge of the viewport, measured outwards\n");
    printf("                   from the viewport in units of the character\n");
    printf("                   height. Use a negative value to write inside the\n");
    printf("                   viewport, a positive value to write outside.\n");
    printf(" COORD  (input)  : the location of the character string along the\n");
    printf("                   specified edge of the viewport, as a fraction of\n");
    printf("                   the length of the edge.\n");
    printf(" FJUST  (input)  : controls justification of the string parallel to\n");
    printf("                   the specified edge of the viewport. If\n");
    printf("                   FJUST = 0.0, the left-hand end of the string will\n");
    printf("                   be placed at COORD; if JUST = 0.5, the center of\n");
    printf("                   the string will be placed at COORD; if JUST = 1.0,\n");
    printf("                   the right-hand end of the string will be placed at\n");
    printf("                   at COORD. Other values between 0 and 1 give inter-\n");
    printf("                   mediate placing, but they are not very useful.\n");
    printf(" TEXT   (input) :  the text string to be plotted. Trailing spaces are\n");
    printf("                   ignored when justifying the string, but leading\n");
    printf("                   spaces are significant.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGNCUR") == 0) {
    printf("    PGNCUR -- mark a set of points using the cursor\n");
    printf("\n");
    printf("\n");
    printf("void cpgncur(int maxpt, int *npt, float *x, float *y, int symbol);\n");
    printf("\n");
    printf("      SUBROUTINE PGNCUR (MAXPT, NPT, X, Y, SYMBOL)\n");
    printf("      INTEGER MAXPT, NPT\n");
    printf("      REAL    X(*), Y(*)\n");
    printf("      INTEGER SYMBOL\n");
    printf("\n");
    printf("Interactive routine for user to enter data points by use of\n");
    printf("the cursor.  Routine allows user to Add and Delete points.  The\n");
    printf("points are returned in order of increasing x-coordinate, not in the\n");
    printf("order they were entered.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" MAXPT  (input)  : maximum number of points that may be accepted.\n");
    printf(" NPT    (in/out) : number of points entered; should be zero on\n");
    printf("                   first call.\n");
    printf(" X      (in/out) : array of x-coordinates.\n");
    printf(" Y      (in/out) : array of y-coordinates.\n");
    printf(" SYMBOL (input)  : code number of symbol to use for marking\n");
    printf("                   entered points (see PGPT <#PGPT>).\n");
    printf("\n");
    printf("Note (1): The dimension of arrays X and Y must be greater than or\n");
    printf("equal to MAXPT.\n");
    printf("\n");
    printf("Note (2): On return from the program, cursor points are returned in\n");
    printf("increasing order of X. Routine may be (re-)called with points\n");
    printf("already defined in X,Y (number in NPT), and they will be plotted\n");
    printf("first, before editing.\n");
    printf("\n");
    printf("Note (3): User commands: the user types single-character commands\n");
    printf("after positioning the cursor: the following are accepted:\n");
    printf("A (Add)    - add point at current cursor location.\n");
    printf("D (Delete) - delete nearest point to cursor.\n");
    printf("X (eXit)   - leave subroutine.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGNUMB") == 0) {
    printf("    PGNUMB -- convert a number into a plottable character string\n");
    printf("\n");
    printf("\n");
    printf("void cpgnumb(int mm, int pp, int form, char *string, \\n");
    printf(" int *string_length);\n");
    printf("\n");
    printf("      SUBROUTINE PGNUMB (MM, PP, FORM, STRING, NC)\n");
    printf("      INTEGER MM, PP, FORM\n");
    printf("      CHARACTER*(*) STRING\n");
    printf("      INTEGER NC\n");
    printf("\n");
    printf("This routine converts a number into a decimal character\n");
    printf("representation. To avoid problems of floating-point roundoff, the\n");
    printf("number must be provided as an integer (MM) multiplied by a power of 10\n");
    printf("(10**PP).  The output string retains only significant digits of MM,\n");
    printf("and will be in either integer format (123), decimal format (0.0123),\n");
    printf("or exponential format (1.23x10**5). Standard escape sequences \\u, \\d \n");
    printf("raise the exponent and \\x is used for the multiplication sign.\n");
    printf("This routine is used by PGBOX <#PGBOX> to create numeric labels for a plot.\n");
    printf("\n");
    printf("Formatting rules:\n");
    printf("  (a) Decimal notation (FORM=1):\n");
    printf("      - Trailing zeros to the right of the decimal sign are\n");
    printf("        omitted\n");
    printf("      - The decimal sign is omitted if there are no digits\n");
    printf("        to the right of it\n");
    printf("      - When the decimal sign is placed before the first digit\n");
    printf("        of the number, a zero is placed before the decimal sign\n");
    printf("      - The decimal sign is a period (.)\n");
    printf("      - No spaces are placed between digits (ie digits are not\n");
    printf("        grouped in threes as they should be)\n");
    printf("      - A leading minus (-) is added if the number is negative\n");
    printf("  (b) Exponential notation (FORM=2):\n");
    printf("      - The exponent is adjusted to put just one (non-zero)\n");
    printf("        digit before the decimal sign\n");
    printf("      - The mantissa is formatted as in (a), unless its value is\n");
    printf("        1 in which case it and the multiplication sign are omitted\n");
    printf("      - If the power of 10 is not zero and the mantissa is not\n");
    printf("        zero, an exponent of the form \\x10\\u[-]nnn is appended,\n");
    printf("        where \\x is a multiplication sign (cross), \\u is an escape\n");
    printf("        sequence to raise the exponent, and as many digits nnn\n");
    printf("        are used as needed\n");
    printf("  (c) Automatic choice (FORM=0):\n");
    printf("        Decimal notation is used if the absolute value of the\n");
    printf("        number is greater than or equal to 0.01 and less than 10000.\n");
    printf("        Otherwise exponential notation is used.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" MM     (input)\n");
    printf(" PP     (input)  : the value to be formatted is MM*10**PP.\n");
    printf(" FORM   (input)  : controls how the number is formatted:\n");
    printf("                   FORM = 0 -- use either decimal or exponential\n");
    printf("                   FORM = 1 -- use decimal notation\n");
    printf("                   FORM = 2 -- use exponential notation\n");
    printf(" STRING (output) : the formatted character string, left justified.\n");
    printf("                   If the length of STRING is insufficient, a single\n");
    printf("                   asterisk is returned, and NC=1.\n");
    printf(" NC     (output) : the number of characters used in STRING:\n");
    printf("                   the string to be printed is STRING(1:NC).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGOLIN") == 0) {
    printf("    PGOLIN -- mark a set of points using the cursor\n");
    printf("\n");
    printf("\n");
    printf("void cpgolin(int maxpt, int *npt, float *x, float *y, int symbol);\n");
    printf("\n");
    printf("      SUBROUTINE PGOLIN (MAXPT, NPT, X, Y, SYMBOL)\n");
    printf("      INTEGER MAXPT, NPT\n");
    printf("      REAL    X(*), Y(*)\n");
    printf("      INTEGER SYMBOL\n");
    printf("\n");
    printf("Interactive routine for user to enter data points by use of\n");
    printf("the cursor.  Routine allows user to Add and Delete points.  The\n");
    printf("points are returned in the order that they were entered (unlike\n");
    printf("PGNCUR <#PGNCUR>).\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" MAXPT  (input)  : maximum number of points that may be accepted.\n");
    printf(" NPT    (in/out) : number of points entered; should be zero on\n");
    printf("                   first call.\n");
    printf(" X      (in/out) : array of x-coordinates.\n");
    printf(" Y      (in/out) : array of y-coordinates.\n");
    printf(" SYMBOL (input)  : code number of symbol to use for marking\n");
    printf("                   entered points (see PGPT <#PGPT>).\n");
    printf("\n");
    printf("Note (1): The dimension of arrays X and Y must be greater than or\n");
    printf("equal to MAXPT.\n");
    printf("\n");
    printf("Note (2): On return from the program, cursor points are returned in\n");
    printf("the order they were entered. Routine may be (re-)called with points\n");
    printf("already defined in X,Y (number in NPT), and they will be plotted\n");
    printf("first, before editing.\n");
    printf("\n");
    printf("Note (3): User commands: the user types single-character commands\n");
    printf("after positioning the cursor: the following are accepted:\n");
    printf("A (Add)    - add point at current cursor location.\n");
    printf("D (Delete) - delete the last point entered.\n");
    printf("X (eXit)   - leave subroutine.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGOPEN") == 0) {
    printf("    PGOPEN -- open a graphics device\n");
    printf("\n");
    printf("\n");
    printf("int cpgopen(const char *device);\n");
    printf("\n");
    printf("      INTEGER FUNCTION PGOPEN (DEVICE)\n");
    printf("      CHARACTER*(*) DEVICE\n");
    printf("\n");
    printf("Open a graphics device for PGPLOT output. If the device is\n");
    printf("opened successfully, it becomes the selected device to which\n");
    printf("graphics output is directed until another device is selected\n");
    printf("with PGSLCT <#PGSLCT> or the device is closed with PGCLOS <#PGCLOS>.\n");
    printf("\n");
    printf("The value returned by PGOPEN <#PGOPEN> should be tested to ensure that\n");
    printf("the device was opened successfully, e.g.,\n");
    printf("\n");
    printf("      ISTAT = PGOPEN <#PGOPEN>('plot.ps/PS')\n");
    printf("      IF (ISTAT .LE. 0 ) STOP\n");
    printf("\n");
    printf("Note that PGOPEN <#PGOPEN> must be declared INTEGER in the calling program.\n");
    printf("\n");
    printf("The DEVICE argument is a character constant or variable; its value\n");
    printf("should be one of the following:\n");
    printf("\n");
    printf("(1) A complete device specification of the form 'device/type' or\n");
    printf("    'file/type', where 'type' is one of the allowed PGPLOT device\n");
    printf("    types (installation-dependent) and 'device' or 'file' is the \n");
    printf("    name of a graphics device or disk file appropriate for this type.\n");
    printf("    The 'device' or 'file' may contain '/' characters; the final\n");
    printf("    '/' delimits the 'type'. If necessary to avoid ambiguity,\n");
    printf("    the 'device' part of the string may be enclosed in double\n");
    printf("    quotation marks.\n");
    printf("(2) A device specification of the form '/type', where 'type' is one\n");
    printf("    of the allowed PGPLOT device types. PGPLOT supplies a default\n");
    printf("    file or device name appropriate for this device type.\n");
    printf("(3) A device specification with '/type' omitted; in this case\n");
    printf("    the type is taken from the environment variable PGPLOT_TYPE,\n");
    printf("    if defined (e.g., setenv PGPLOT_TYPE PS). Because of possible\n");
    printf("    confusion with '/' in file-names, omitting the device type\n");
    printf("    in this way is not recommended.\n");
    printf("(4) A blank string (' '); in this case, PGOPEN <#PGOPEN> will use the value\n");
    printf("    of environment variable PGPLOT_DEV as the device specification,\n");
    printf("    or '/NULL' if the environment variable is undefined.\n");
    printf("(5) A single question mark, with optional trailing spaces ('?'); in\n");
    printf("    this case, PGPLOT will prompt the user to supply the device\n");
    printf("    specification, with a prompt string of the form\n");
    printf("        'Graphics device/type (? to see list, default XXX):'\n");
    printf("    where 'XXX' is the default (value of environment variable\n");
    printf("    PGPLOT_DEV).\n");
    printf("(6) A non-blank string in which the first character is a question\n");
    printf("    mark (e.g., '?Device: '); in this case, PGPLOT will prompt the\n");
    printf("    user to supply the device specification, using the supplied\n");
    printf("    string as the prompt (without the leading question mark but\n");
    printf("    including any trailing spaces).\n");
    printf("\n");
    printf("In cases (5) and (6), the device specification is read from the\n");
    printf("standard input. The user should respond to the prompt with a device\n");
    printf("specification of the form (1), (2), or (3). If the user types a \n");
    printf("question-mark in response to the prompt, a list of available device\n");
    printf("types is displayed and the prompt is re-issued. If the user supplies\n");
    printf("an invalid device specification, the prompt is re-issued. If the user\n");
    printf("responds with an end-of-file character, e.g., ctrl-D in UNIX, program\n");
    printf("execution is aborted; this  avoids the possibility of an infinite\n");
    printf("prompting loop.  A programmer should avoid use of PGPLOT-prompting\n");
    printf("if this behavior is not desirable.\n");
    printf("\n");
    printf("The device type is case-insensitive (e.g., '/ps' and '/PS' are \n");
    printf("equivalent). The device or file name may be case-sensitive in some\n");
    printf("operating systems.\n");
    printf("\n");
    printf("Examples of valid DEVICE arguments:\n");
    printf("\n");
    printf("(1)  'plot.ps/ps', 'dir/plot.ps/ps', '\"dir/plot.ps\"/ps', \n");
    printf("     'user:[tjp.plots]plot.ps/PS'\n");
    printf("(2)  '/ps'      (PGPLOT interprets this as 'pgplot.ps/ps')\n");
    printf("(3)  'plot.ps'  (if PGPLOT_TYPE is defined as 'ps', PGPLOT\n");
    printf("                 interprets this as 'plot.ps/ps')\n");
    printf("(4)  '   '      (if PGPLOT_DEV is defined)\n");
    printf("(5)  '?  '\n");
    printf("(6)  '?Device specification for PGPLOT: '\n");
    printf("\n");
    printf("[This routine was added to PGPLOT in Version 5.1.0. Older programs\n");
    printf("use PGBEG <#PGBEG> instead.]\n");
    printf("\n");
    printf("Returns:\n");
    printf(" PGOPEN <#PGOPEN>          : returns either a positive value, the\n");
    printf("                   identifier of the graphics device for use with\n");
    printf("                   PGSLCT <#PGSLCT>, or a 0 or negative value indicating an\n");
    printf("                   error. In the event of error a message is\n");
    printf("                   written on the standard error unit.\n");
    printf("Arguments:\n");
    printf(" DEVICE  (input) : the 'device specification' for the plot device\n");
    printf("                   (see above).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGPAGE") == 0) {
    printf("    PGPAGE -- advance to new page\n");
    printf("\n");
    printf("\n");
    printf("void cpgpage(void);\n");
    printf("\n");
    printf("      SUBROUTINE PGPAGE\n");
    printf("\n");
    printf("Advance plotter to a new page or panel, clearing the screen if\n");
    printf("necessary. If the \"prompt state\" is ON (see PGASK <#PGASK>), confirmation is\n");
    printf("requested from the user before clearing the screen. If the view\n");
    printf("surface has been subdivided into panels with PGBEG <#PGBEG> or PGSUBP <#PGSUBP>, then\n");
    printf("PGPAGE <#PGPAGE> advances to the next panel, and if the current panel is the\n");
    printf("last on the page, PGPAGE <#PGPAGE> clears the screen or starts a new sheet of\n");
    printf("paper.  PGPAGE <#PGPAGE> does not change the PGPLOT window or the viewport\n");
    printf("(in normalized device coordinates); but note that if the size of the\n");
    printf("view-surface is changed externally (e.g., by a workstation window\n");
    printf("manager) the size of the viewport is changed in proportion.\n");
    printf("\n");
    printf("Arguments: none\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGPANL") == 0) {
    printf("    PGPANL -- switch to a different panel on the view surface\n");
    printf("\n");
    printf("\n");
    printf("void cpgpanl(int nxc, int nyc);\n");
    printf("\n");
    printf("      SUBROUTINE PGPANL(IX, IY)\n");
    printf("      INTEGER IX, IY\n");
    printf("\n");
    printf("Start plotting in a different panel. If the view surface has been\n");
    printf("divided into panels by PGBEG <#PGBEG> or PGSUBP <#PGSUBP>, this routine can be used to\n");
    printf("move to a different panel. Note that PGPLOT does not remember what\n");
    printf("viewport and window were in use in each panel; these should be reset\n");
    printf("if necessary after calling PGPANL <#PGPANL>. Nor does PGPLOT clear the panel:\n");
    printf("call PGERAS <#PGERAS> after calling PGPANL <#PGPANL> to do this.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" IX     (input)  : the horizontal index of the panel (in the range\n");
    printf("                   1 <= IX <= number of panels in horizontal\n");
    printf("                   direction).\n");
    printf(" IY     (input)  : the vertical index of the panel (in the range\n");
    printf("                   1 <= IY <= number of panels in horizontal\n");
    printf("                   direction).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGPAP") == 0) {
    printf("    PGPAP -- change the size of the view surface\n");
    printf("\n");
    printf("\n");
    printf("void cpgpap(float width, float aspect);\n");
    printf("\n");
    printf("      SUBROUTINE PGPAP (WIDTH, ASPECT)\n");
    printf("      REAL WIDTH, ASPECT\n");
    printf("\n");
    printf("This routine changes the size of the view surface (\"paper size\") to a\n");
    printf("specified width and aspect ratio (height/width), in so far as this is\n");
    printf("possible on the specific device. It is always possible to obtain a\n");
    printf("view surface smaller than the default size; on some devices (e.g.,\n");
    printf("printers that print on roll or fan-feed paper) it is possible to \n");
    printf("obtain a view surface larger than the default.\n");
    printf("\n");
    printf("This routine should be called either immediately after PGBEG <#PGBEG> or\n");
    printf("immediately before PGPAGE <#PGPAGE>. The new size applies to all subsequent\n");
    printf("images until the next call to PGPAP <#PGPAP>.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" WIDTH  (input)  : the requested width of the view surface in inches;\n");
    printf("                   if WIDTH=0.0, PGPAP <#PGPAP> will obtain the largest view\n");
    printf("                   surface available consistent with argument ASPECT.\n");
    printf("                   (1 inch = 25.4 mm.)\n");
    printf(" ASPECT (input)  : the aspect ratio (height/width) of the view\n");
    printf("                   surface; e.g., ASPECT=1.0 gives a square view\n");
    printf("                   surface, ASPECT=0.618 gives a horizontal\n");
    printf("                   rectangle, ASPECT=1.618 gives a vertical rectangle.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGPIXL") == 0) {
    printf("    PGPIXL -- draw pixels\n");
    printf("\n");
    printf("\n");
    printf("void cpgpixl(const int *ia, int idim, int jdim, int i1, int i2, \\n");
    printf(" int j1, int j2, float x1, float x2, float y1, float y2);\n");
    printf("\n");
    printf("      SUBROUTINE PGPIXL (IA, IDIM, JDIM, I1, I2, J1, J2, \n");
    printf("     1                   X1, X2, Y1, Y2)\n");
    printf("      INTEGER IDIM, JDIM, I1, I2, J1, J2\n");
    printf("      INTEGER IA(IDIM,JDIM)\n");
    printf("      REAL    X1, X2, Y1, Y2\n");
    printf("\n");
    printf("Draw lots of solid-filled (tiny) rectangles aligned with the\n");
    printf("coordinate axes. Best performance is achieved when output is\n");
    printf("directed to a pixel-oriented device and the rectangles coincide\n");
    printf("with the pixels on the device. In other cases, pixel output is\n");
    printf("emulated.\n");
    printf("\n");
    printf("The subsection of the array IA defined by indices (I1:I2, J1:J2)\n");
    printf("is mapped onto world-coordinate rectangle defined by X1, X2, Y1\n");
    printf("and Y2. This rectangle is divided into (I2 - I1 + 1) * (J2 - J1 + 1)\n");
    printf("small rectangles. Each of these small rectangles is solid-filled\n");
    printf("with the color index specified by the corresponding element of \n");
    printf("IA.\n");
    printf("\n");
    printf("On most devices, the output region is \"opaque\", i.e., it obscures\n");
    printf("all graphical elements previously drawn in the region. But on\n");
    printf("devices that do not have erase capability, the background shade\n");
    printf("is \"transparent\" and allows previously-drawn graphics to show\n");
    printf("through.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" IA     (input)  : the array to be plotted.\n");
    printf(" IDIM   (input)  : the first dimension of array A.\n");
    printf(" JDIM   (input)  : the second dimension of array A.\n");
    printf(" I1, I2 (input)  : the inclusive range of the first index\n");
    printf("                   (I) to be plotted.\n");
    printf(" J1, J2 (input)  : the inclusive range of the second\n");
    printf("                   index (J) to be plotted.\n");
    printf(" X1, Y1 (input)  : world coordinates of one corner of the output\n");
    printf("                   region\n");
    printf(" X2, Y2 (input)  : world coordinates of the opposite corner of the\n");
    printf("                   output region\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGPNTS") == 0) {
    printf("    PGPNTS -- draw several graph markers, not all the same\n");
    printf("\n");
    printf("\n");
    printf("void cpgpnts(int n, const float *x, const float *y, \\n");
    printf(" const int *symbol, int ns);\n");
    printf("\n");
    printf("      SUBROUTINE PGPNTS (N, X, Y, SYMBOL, NS)\n");
    printf("      INTEGER N, NS\n");
    printf("      REAL X(*), Y(*)\n");
    printf("      INTEGER SYMBOL(*)\n");
    printf("\n");
    printf("Draw Graph Markers. Unlike PGPT <#PGPT>, this routine can draw a different\n");
    printf("symbol at each point. The markers are drawn using the current values\n");
    printf("of attributes color-index, line-width, and character-height\n");
    printf("(character-font applies if the symbol number is >31).  If the point\n");
    printf("to be marked lies outside the window, no marker is drawn.  The \"pen \n");
    printf("position\" is changed to (XPTS(N),YPTS(N)) in world coordinates\n");
    printf("(if N > 0).\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" N      (input)  : number of points to mark.\n");
    printf(" X      (input)  : world x-coordinate of the points.\n");
    printf(" Y      (input)  : world y-coordinate of the points.\n");
    printf(" SYMBOL (input)  : code number of the symbol to be plotted at each\n");
    printf("                   point (see PGPT <#PGPT>).\n");
    printf(" NS     (input)  : number of values in the SYMBOL array.  If NS <= N,\n");
    printf("                   then the first NS points are drawn using the value\n");
    printf("                   of SYMBOL(I) at (X(I), Y(I)) and SYMBOL(1) for all\n");
    printf("                   the values of (X(I), Y(I)) where I > NS.\n");
    printf("\n");
    printf("Note: the dimension of arrays X and Y must be greater than or equal\n");
    printf("to N and the dimension of the array SYMBOL must be greater than or\n");
    printf("equal to NS.  If N is 1, X and Y may be scalars (constants or\n");
    printf("variables).  If NS is 1, then SYMBOL may be a scalar.  If N is\n");
    printf("less than 1, nothing is drawn.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGPOLY") == 0) {
    printf("    PGPOLY -- draw a polygon, using fill-area attributes\n");
    printf("\n");
    printf("\n");
    printf("void cpgpoly(int n, const float *xpts, const float *ypts);\n");
    printf("\n");
    printf("      SUBROUTINE PGPOLY (N, XPTS, YPTS)\n");
    printf("      INTEGER N\n");
    printf("      REAL XPTS(*), YPTS(*)\n");
    printf("\n");
    printf("Fill-area primitive routine: shade the interior of a closed\n");
    printf("polygon in the current window.  The action of this routine depends\n");
    printf("on the setting of the Fill-Area Style attribute (see PGSFS <#PGSFS>).\n");
    printf("The polygon is clipped at the edge of the\n");
    printf("window. The pen position is changed to (XPTS(1),YPTS(1)) in world\n");
    printf("coordinates (if N > 1).  If the polygon is not convex, a point is\n");
    printf("assumed to lie inside the polygon if a straight line drawn to\n");
    printf("infinity intersects and odd number of the polygon's edges.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" N      (input)  : number of points defining the polygon; the\n");
    printf("                   line consists of N straight-line segments,\n");
    printf("                   joining points 1 to 2, 2 to 3,... N-1 to N, N to 1.\n");
    printf("                   N should be greater than 2 (if it is 2 or less,\n");
    printf("                   nothing will be drawn).\n");
    printf(" XPTS   (input)  : world x-coordinates of the vertices.\n");
    printf(" YPTS   (input)  : world y-coordinates of the vertices.\n");
    printf("                   Note: the dimension of arrays XPTS and YPTS must be\n");
    printf("                   greater than or equal to N.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGPT") == 0) {
    printf("    PGPT -- draw several graph markers\n");
    printf("\n");
    printf("\n");
    printf("void cpgpt(int n, const float *xpts, const float *ypts, int symbol);\n");
    printf("\n");
    printf("      SUBROUTINE PGPT (N, XPTS, YPTS, SYMBOL)\n");
    printf("      INTEGER N\n");
    printf("      REAL XPTS(*), YPTS(*)\n");
    printf("      INTEGER SYMBOL\n");
    printf("\n");
    printf("Primitive routine to draw Graph Markers (polymarker). The markers\n");
    printf("are drawn using the current values of attributes color-index,\n");
    printf("line-width, and character-height (character-font applies if the symbol\n");
    printf("number is >31).  If the point to be marked lies outside the window,\n");
    printf("no marker is drawn.  The \"pen position\" is changed to\n");
    printf("(XPTS(N),YPTS(N)) in world coordinates (if N > 0).\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" N      (input)  : number of points to mark.\n");
    printf(" XPTS   (input)  : world x-coordinates of the points.\n");
    printf(" YPTS   (input)  : world y-coordinates of the points.\n");
    printf(" SYMBOL (input)  : code number of the symbol to be drawn at each \n");
    printf("                   point:\n");
    printf("                   -1, -2  : a single dot (diameter = current\n");
    printf("                             line width).\n");
    printf("                   -3..-31 : a regular polygon with ABS(SYMBOL)\n");
    printf("                             edges (style set by current fill style).\n");
    printf("                   0..31   : standard marker symbols.\n");
    printf("                   32..127 : ASCII characters (in current font).\n");
    printf("                             e.g. to use letter F as a marker, let\n");
    printf("                             SYMBOL = ICHAR('F'). \n");
    printf("                   > 127  :  a Hershey symbol number.\n");
    printf("\n");
    printf("Note: the dimension of arrays X and Y must be greater than or equal\n");
    printf("to N. If N is 1, X and Y may be scalars (constants or variables). If\n");
    printf("N is less than 1, nothing is drawn.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGPT1") == 0) {
    printf("    PGPT1 -- draw one graph marker\n");
    printf("\n");
    printf("\n");
    printf("void cpgpt1(float xpt, float ypt, int symbol);\n");
    printf("\n");
    printf("      SUBROUTINE PGPT1 (XPT, YPT, SYMBOL)\n");
    printf("      REAL XPT, YPT\n");
    printf("      INTEGER SYMBOL\n");
    printf("\n");
    printf("Primitive routine to draw a single Graph Marker at a specified point.\n");
    printf("The marker is drawn using the current values of attributes\n");
    printf("color-index, line-width, and character-height (character-font applies\n");
    printf("if the symbol number is >31).  If the point to be marked lies outside\n");
    printf("the window, no marker is drawn.  The \"pen position\" is changed to\n");
    printf("(XPT,YPT) in world coordinates.\n");
    printf("\n");
    printf("To draw several markers with coordinates specified by X and Y\n");
    printf("arrays, use routine PGPT <#PGPT>.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" XPT    (input)  : world x-coordinate of the point.\n");
    printf(" YPT    (input)  : world y-coordinate of the point.\n");
    printf(" SYMBOL (input)  : code number of the symbol to be drawn:\n");
    printf("                   -1, -2  : a single dot (diameter = current\n");
    printf("                             line width).\n");
    printf("                   -3..-31 : a regular polygon with ABS(SYMBOL)\n");
    printf("                             edges (style set by current fill style).\n");
    printf("                   0..31   : standard marker symbols.\n");
    printf("                   32..127 : ASCII characters (in current font).\n");
    printf("                             e.g. to use letter F as a marker, let\n");
    printf("                             SYMBOL = ICHAR('F'). \n");
    printf("                   > 127  :  a Hershey symbol number.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGPTXT") == 0) {
    printf("    PGPTXT -- write text at arbitrary position and angle\n");
    printf("\n");
    printf("\n");
    printf("void cpgptxt(float x, float y, float angle, float fjust, \\n");
    printf(" const char *text);\n");
    printf("\n");
    printf("      SUBROUTINE PGPTXT (X, Y, ANGLE, FJUST, TEXT)\n");
    printf("      REAL X, Y, ANGLE, FJUST\n");
    printf("      CHARACTER*(*) TEXT\n");
    printf("\n");
    printf("Primitive routine for drawing text. The text may be drawn at any\n");
    printf("angle with the horizontal, and may be centered or left- or right-\n");
    printf("justified at a specified position.  Routine PGTEXT <#PGTEXT> provides a\n");
    printf("simple interface to PGPTXT <#PGPTXT> for horizontal strings. Text is drawn\n");
    printf("using the current values of attributes color-index, line-width,\n");
    printf("character-height, and character-font.  Text is NOT subject to\n");
    printf("clipping at the edge of the window.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X      (input)  : world x-coordinate.\n");
    printf(" Y      (input)  : world y-coordinate. The string is drawn with the\n");
    printf("                   baseline of all the characters passing through\n");
    printf("                   point (X,Y); the positioning of the string along\n");
    printf("                   this line is controlled by argument FJUST.\n");
    printf(" ANGLE  (input)  : angle, in degrees, that the baseline is to make\n");
    printf("                   with the horizontal, increasing counter-clockwise\n");
    printf("                   (0.0 is horizontal).\n");
    printf(" FJUST  (input)  : controls horizontal justification of the string.\n");
    printf("                   If FJUST = 0.0, the string will be left-justified\n");
    printf("                   at the point (X,Y); if FJUST = 0.5, it will be\n");
    printf("                   centered, and if FJUST = 1.0, it will be right\n");
    printf("                   justified. [Other values of FJUST give other\n");
    printf("                   justifications.]\n");
    printf(" TEXT   (input)  : the character string to be plotted.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQAH") == 0) {
    printf("    PGQAH -- inquire arrow-head style\n");
    printf("\n");
    printf("\n");
    printf("void cpgqah(int *fs, float *angle, float *barb);\n");
    printf("\n");
    printf("      SUBROUTINE PGQAH (FS, ANGLE, BARB)\n");
    printf("      INTEGER  FS\n");
    printf("      REAL ANGLE, BARB\n");
    printf("\n");
    printf("Query the style to be used for arrowheads drawn with routine PGARRO <#PGARRO>.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" FS     (output) : FS = 1 => filled; FS = 2 => outline.\n");
    printf(" ANGLE  (output) : the acute angle of the arrow point, in degrees.\n");
    printf(" BARB   (output) : the fraction of the triangular arrow-head that\n");
    printf("                   is cut away from the back. \n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQCF") == 0) {
    printf("    PGQCF -- inquire character font\n");
    printf("\n");
    printf("\n");
    printf("void cpgqcf(int *font);\n");
    printf("\n");
    printf("      SUBROUTINE PGQCF (FONT)\n");
    printf("      INTEGER  FONT\n");
    printf("\n");
    printf("Query the current Character Font (set by routine PGSCF <#PGSCF>).\n");
    printf("\n");
    printf("Argument:\n");
    printf(" FONT   (output)   : the current font number (in range 1-4).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQCH") == 0) {
    printf("    PGQCH -- inquire character height\n");
    printf("\n");
    printf("\n");
    printf("void cpgqch(float *size);\n");
    printf("\n");
    printf("      SUBROUTINE PGQCH (SIZE)\n");
    printf("      REAL SIZE\n");
    printf("\n");
    printf("Query the Character Size attribute (set by routine PGSCH <#PGSCH>).\n");
    printf("\n");
    printf("Argument:\n");
    printf(" SIZE   (output) : current character size (dimensionless multiple of\n");
    printf("                   the default size).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQCI") == 0) {
    printf("    PGQCI -- inquire color index\n");
    printf("\n");
    printf("\n");
    printf("void cpgqci(int *ci);\n");
    printf("\n");
    printf("      SUBROUTINE PGQCI (CI)\n");
    printf("      INTEGER  CI\n");
    printf("\n");
    printf("Query the Color Index attribute (set by routine PGSCI <#PGSCI>).\n");
    printf("\n");
    printf("Argument:\n");
    printf(" CI     (output) : the current color index (in range 0-max). This is\n");
    printf("                   the color index actually in use, and may differ\n");
    printf("                   from the color index last requested by PGSCI <#PGSCI> if\n");
    printf("                   that index is not available on the output device.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQCIR") == 0) {
    printf("    PGQCIR -- inquire color index range\n");
    printf("\n");
    printf("\n");
    printf("void cpgqcir(int *icilo, int *icihi);\n");
    printf("\n");
    printf("      SUBROUTINE PGQCIR(ICILO, ICIHI)\n");
    printf("      INTEGER   ICILO, ICIHI\n");
    printf("\n");
    printf("Query the color index range to be used for producing images with\n");
    printf("PGGRAY <#PGGRAY> or PGIMAG <#PGIMAG>, as set by routine PGSCIR <#PGSCIR> or by device default.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" ICILO  (output) : the lowest color index to use for images\n");
    printf(" ICIHI  (output) : the highest color index to use for images\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQCLP") == 0) {
    printf("    PGQCLP -- inquire clipping status\n");
    printf("\n");
    printf("\n");
    printf("void cpgqclp(int *state);\n");
    printf("\n");
    printf("      SUBROUTINE PGQCLP(STATE)\n");
    printf("      INTEGER  STATE\n");
    printf("\n");
    printf("Query the current clipping status (set by routine PGSCLP <#PGSCLP>).\n");
    printf("\n");
    printf("Argument:\n");
    printf(" STATE  (output) : receives the clipping status (0 => disabled,\n");
    printf("                   1 => enabled).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQCOL") == 0) {
    printf("    PGQCOL -- inquire color capability\n");
    printf("\n");
    printf("\n");
    printf("void cpgqcol(int *ci1, int *ci2);\n");
    printf("\n");
    printf("      SUBROUTINE PGQCOL (CI1, CI2)\n");
    printf("      INTEGER  CI1, CI2\n");
    printf("\n");
    printf("Query the range of color indices available on the current device.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" CI1    (output) : the minimum available color index. This will be\n");
    printf("                   either 0 if the device can write in the\n");
    printf("                   background color, or 1 if not.\n");
    printf(" CI2    (output) : the maximum available color index. This will be\n");
    printf("                   1 if the device has no color capability, or a\n");
    printf("                   larger number (e.g., 3, 7, 15, 255).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQCR") == 0) {
    printf("    PGQCR -- inquire color representation\n");
    printf("\n");
    printf("\n");
    printf("void cpgqcr(int ci, float *cr, float *cg, float *cb);\n");
    printf("\n");
    printf("      SUBROUTINE PGQCR (CI, CR, CG, CB)\n");
    printf("      INTEGER CI\n");
    printf("      REAL    CR, CG, CB\n");
    printf("\n");
    printf("Query the RGB colors associated with a color index.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" CI  (input)  : color index\n");
    printf(" CR  (output) : red, green and blue intensities\n");
    printf(" CG  (output)   in the range 0.0 to 1.0\n");
    printf(" CB  (output)\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQCS") == 0) {
    printf("    PGQCS -- inquire character height in a variety of units\n");
    printf("\n");
    printf("\n");
    printf("void cpgqcs(int units, float *xch, float *ych);\n");
    printf("\n");
    printf("      SUBROUTINE PGQCS(UNITS, XCH, YCH)\n");
    printf("      INTEGER UNITS\n");
    printf("      REAL XCH, YCH\n");
    printf("\n");
    printf("Return the current PGPLOT character height in a variety of units.\n");
    printf("This routine provides facilities that are not available via PGQCH <#PGQCH>.\n");
    printf("Use PGQCS <#PGQCS> if the character height is required in units other than\n");
    printf("those used in PGSCH <#PGSCH>.\n");
    printf("\n");
    printf("The PGPLOT \"character height\" is a dimension that scales with the\n");
    printf("size of the view surface and with the scale-factor specified with\n");
    printf("routine PGSCH <#PGSCH>. The default value is 1/40th of the height or width\n");
    printf("of the view surface (whichever is less); this value is then\n");
    printf("multiplied by the scale-factor supplied with PGSCH <#PGSCH>. Note that it\n");
    printf("is a nominal height only; the actual character size depends on the\n");
    printf("font and is usually somewhat smaller.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" UNITS  (input)  : Used to specify the units of the output value:\n");
    printf("                   UNITS = 0 : normalized device coordinates\n");
    printf("                   UNITS = 1 : inches\n");
    printf("                   UNITS = 2 : millimeters\n");
    printf("                   UNITS = 3 : pixels\n");
    printf("                   UNITS = 4 : world coordinates\n");
    printf("                   Other values give an error message, and are\n");
    printf("                   treated as 0.\n");
    printf(" XCH    (output) : The character height for text written with a\n");
    printf("                   vertical baseline.\n");
    printf(" YCH    (output) : The character height for text written with\n");
    printf("                   a horizontal baseline (the usual case).\n");
    printf("\n");
    printf("The character height is returned in both XCH and YCH.\n");
    printf("\n");
    printf("If UNITS=1 or UNITS=2, XCH and YCH both receive the same value.\n");
    printf("\n");
    printf("If UNITS=3, XCH receives the height in horizontal pixel units, and YCH\n");
    printf("receives the height in vertical pixel units; on devices for which the\n");
    printf("pixels are not square, XCH and YCH will be different.\n");
    printf("\n");
    printf("If UNITS=4, XCH receives the height in horizontal world coordinates\n");
    printf("(as used for the x-axis), and YCH receives the height in vertical\n");
    printf("world coordinates (as used for the y-axis). Unless special care has\n");
    printf("been taken to achive equal world-coordinate scales on both axes, the\n");
    printf("values of XCH and YCH will be different.\n");
    printf("\n");
    printf("If UNITS=0, XCH receives the character height as a fraction of the\n");
    printf("horizontal dimension of the view surface, and YCH receives the\n");
    printf("character height as a fraction of the vertical dimension of the view\n");
    printf("surface.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQDT") == 0) {
    printf("    PGQDT -- inquire name of nth available device type\n");
    printf("\n");
    printf("\n");
    printf("void cpgqdt(int n, char *type, int *type_length, char *descr, \\n");
    printf(" int *descr_length, int *inter);\n");
    printf("\n");
    printf("      SUBROUTINE PGQDT(N, TYPE, TLEN, DESCR, DLEN, INTER)\n");
    printf("      INTEGER N\n");
    printf("      CHARACTER*(*) TYPE, DESCR\n");
    printf("      INTEGER TLEN, DLEN, INTER\n");
    printf("\n");
    printf("Return the name of the Nth available device type as a character\n");
    printf("string. The number of available types can be determined by calling\n");
    printf("PGQNDT <#PGQNDT>. If the value of N supplied is outside the range from 1 to\n");
    printf("the number of available types, the routine returns DLEN=TLEN=0.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" N      (input)  : the number of the device type (1..maximum).\n");
    printf(" TYPE   (output) : receives the character device-type code of the\n");
    printf("                   Nth device type. The argument supplied should be\n");
    printf("                   large enough for at least 8 characters. The first\n");
    printf("                   character in the string is a '/' character.\n");
    printf(" TLEN   (output) : receives the number of characters in TYPE,\n");
    printf("                   excluding trailing blanks.\n");
    printf(" DESCR  (output) : receives a description of the device type. The\n");
    printf("                   argument supplied should be large enough for at\n");
    printf("                   least 64 characters.\n");
    printf(" DLEN   (output) : receives the number of characters in DESCR,\n");
    printf("                   excluding trailing blanks.\n");
    printf(" INTER  (output) : receives 1 if the device type is an interactive\n");
    printf("                   one, 0 otherwise.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQFS") == 0) {
    printf("    PGQFS -- inquire fill-area style\n");
    printf("\n");
    printf("\n");
    printf("void cpgqfs(int *fs);\n");
    printf("\n");
    printf("      SUBROUTINE PGQFS (FS)\n");
    printf("      INTEGER  FS\n");
    printf("\n");
    printf("Query the current Fill-Area Style attribute (set by routine\n");
    printf("PGSFS <#PGSFS>).\n");
    printf("\n");
    printf("Argument:\n");
    printf(" FS     (output) : the current fill-area style:\n");
    printf("                     FS = 1 => solid (default)\n");
    printf("                     FS = 2 => outline\n");
    printf("                     FS = 3 => hatched\n");
    printf("                     FS = 4 => cross-hatched\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQHS") == 0) {
    printf("    PGQHS -- inquire hatching style\n");
    printf("\n");
    printf("\n");
    printf("void cpgqhs(float *angle, float *sepn, float* phase);\n");
    printf("\n");
    printf("      SUBROUTINE PGQHS (ANGLE, SEPN, PHASE)\n");
    printf("      REAL ANGLE, SEPN, PHASE\n");
    printf("\n");
    printf("Query the style to be used hatching (fill area with fill-style 3).\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" ANGLE  (output) : the angle the hatch lines make with the\n");
    printf("                   horizontal, in degrees, increasing \n");
    printf("                   counterclockwise (this is an angle on the\n");
    printf("                   view surface, not in world-coordinate space).\n");
    printf(" SEPN   (output) : the spacing of the hatch lines. The unit spacing\n");
    printf("                   is 1 percent of the smaller of the height or\n");
    printf("                   width of the view surface.\n");
    printf(" PHASE  (output) : a real number between 0 and 1; the hatch lines\n");
    printf("                   are displaced by this fraction of SEPN from a\n");
    printf("                   fixed reference.  Adjacent regions hatched with the\n");
    printf("                   same PHASE have contiguous hatch lines.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQID") == 0) {
    printf("    PGQID -- inquire current device identifier\n");
    printf("\n");
    printf("\n");
    printf("void cpgqid(int *id);\n");
    printf("\n");
    printf("      SUBROUTINE PGQID (ID)\n");
    printf("      INTEGER  ID\n");
    printf("\n");
    printf("This subroutine returns the identifier of the currently\n");
    printf("selected device, or 0 if no device is selected.  The identifier is\n");
    printf("assigned when PGOPEN <#PGOPEN> is called to open the device, and may be used\n");
    printf("as an argument to PGSLCT <#PGSLCT>.  Each open device has a different\n");
    printf("identifier.\n");
    printf("\n");
    printf("[This routine was added to PGPLOT in Version 5.1.0.]\n");
    printf("\n");
    printf("Argument:\n");
    printf(" ID     (output) : the identifier of the current device, or 0 if\n");
    printf("                   no device is currently selected.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQINF") == 0) {
    printf("    PGQINF -- inquire PGPLOT general information\n");
    printf("\n");
    printf("\n");
    printf("void cpgqinf(const char *item, char *value, int *value_length);\n");
    printf("\n");
    printf("      SUBROUTINE PGQINF (ITEM, VALUE, LENGTH)\n");
    printf("      CHARACTER*(*) ITEM, VALUE\n");
    printf("      INTEGER LENGTH\n");
    printf("\n");
    printf("This routine can be used to obtain miscellaneous information about\n");
    printf("the PGPLOT environment. Input is a character string defining the\n");
    printf("information required, and output is a character string containing the\n");
    printf("requested information.\n");
    printf("\n");
    printf("The following item codes are accepted (note that the strings must\n");
    printf("match exactly, except for case, but only the first 8 characters are\n");
    printf("significant). For items marked *, PGPLOT must be in the OPEN state\n");
    printf("for the inquiry to succeed. If the inquiry is unsuccessful, either\n");
    printf("because the item code is not recognized or because the information\n");
    printf("is not available, a question mark ('?') is returned.\n");
    printf("\n");
    printf("  'VERSION'     - version of PGPLOT software in use.\n");
    printf("  'STATE'       - status of PGPLOT ('OPEN' if a graphics device\n");
    printf("                  is open for output, 'CLOSED' otherwise).\n");
    printf("  'USER'        - the username associated with the calling program.\n");
    printf("  'NOW'         - current date and time (e.g., '17-FEB-1986 10:04').\n");
    printf("  'DEVICE'    * - current PGPLOT device or file.\n");
    printf("  'FILE'      * - current PGPLOT device or file.\n");
    printf("  'TYPE'      * - device-type of the current PGPLOT device.\n");
    printf("  'DEV/TYPE'  * - current PGPLOT device and type, in a form which\n");
    printf("                  is acceptable as an argument for PGBEG <#PGBEG>.\n");
    printf("  'HARDCOPY'  * - is the current device a hardcopy device? ('YES' or\n");
    printf("                  'NO').\n");
    printf("  'TERMINAL'  * - is the current device the user's interactive\n");
    printf("                  terminal? ('YES' or 'NO').\n");
    printf("  'CURSOR'    * - does the current device have a graphics cursor?\n");
    printf("                  ('YES' or 'NO').\n");
    printf("  'SCROLL'    * - does current device have rectangle-scroll\n");
    printf("                  capability ('YES' or 'NO'); see PGSCRL <#PGSCRL>.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" ITEM  (input)  : character string defining the information to\n");
    printf("                  be returned; see above for a list of possible\n");
    printf("                  values.\n");
    printf(" VALUE (output) : returns a character-string containing the\n");
    printf("                  requested information, truncated to the length \n");
    printf("                  of the supplied string or padded on the right with \n");
    printf("                  spaces if necessary.\n");
    printf(" LENGTH (output): the number of characters returned in VALUE\n");
    printf("                  (excluding trailing blanks).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQITF") == 0) {
    printf("    PGQITF -- inquire image transfer function\n");
    printf("\n");
    printf("\n");
    printf("void cpgqitf(int *itf);\n");
    printf("\n");
    printf("      SUBROUTINE PGQITF (ITF)\n");
    printf("      INTEGER  ITF\n");
    printf("\n");
    printf("Return the Image Transfer Function as set by default or by a previous\n");
    printf("call to PGSITF <#PGSITF>. The Image Transfer Function is used by routines\n");
    printf("PGIMAG <#PGIMAG>, PGGRAY <#PGGRAY>, and PGWEDG <#PGWEDG>.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" ITF    (output) : type of transfer function (see PGSITF <#PGSITF>)\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQLS") == 0) {
    printf("    PGQLS -- inquire line style\n");
    printf("\n");
    printf("\n");
    printf("void cpgqls(int *ls);\n");
    printf("\n");
    printf("      SUBROUTINE PGQLS (LS)\n");
    printf("      INTEGER  LS\n");
    printf("\n");
    printf("Query the current Line Style attribute (set by routine PGSLS <#PGSLS>).\n");
    printf("\n");
    printf("Argument:\n");
    printf(" LS     (output) : the current line-style attribute (in range 1-5).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQLW") == 0) {
    printf("    PGQLW -- inquire line width\n");
    printf("\n");
    printf("\n");
    printf("void cpgqlw(int *lw);\n");
    printf("\n");
    printf("      SUBROUTINE PGQLW (LW)\n");
    printf("      INTEGER  LW\n");
    printf("\n");
    printf("Query the current Line-Width attribute (set by routine PGSLW <#PGSLW>).\n");
    printf("\n");
    printf("Argument:\n");
    printf(" LW     (output)  : the line-width (in range 1-201).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQNDT") == 0) {
    printf("    PGQNDT -- inquire number of available device types\n");
    printf("\n");
    printf("\n");
    printf("void cpgqndt(int *n);\n");
    printf("\n");
    printf("      SUBROUTINE PGQNDT(N)\n");
    printf("      INTEGER N\n");
    printf("\n");
    printf("Return the number of available device types. This routine is\n");
    printf("usually used in conjunction with PGQDT <#PGQDT> to get a list of the\n");
    printf("available device types.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" N      (output) : the number of available device types.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQPOS") == 0) {
    printf("    PGQPOS -- inquire current pen position\n");
    printf("\n");
    printf("\n");
    printf("void cpgqpos(float *x, float *y);\n");
    printf("\n");
    printf("      SUBROUTINE PGQPOS (X, Y)\n");
    printf("      REAL X, Y\n");
    printf("\n");
    printf("Query the current \"pen\" position in world C coordinates (X,Y).\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X      (output)  : world x-coordinate of the pen position.\n");
    printf(" Y      (output)  : world y-coordinate of the pen position.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQTBG") == 0) {
    printf("    PGQTBG -- inquire text background color index\n");
    printf("\n");
    printf("\n");
    printf("void cpgqtbg(int *tbci);\n");
    printf("\n");
    printf("      SUBROUTINE PGQTBG (TBCI)\n");
    printf("      INTEGER  TBCI\n");
    printf("\n");
    printf("Query the current Text Background Color Index (set by routine\n");
    printf("PGSTBG <#PGSTBG>).\n");
    printf("\n");
    printf("Argument:\n");
    printf(" TBCI   (output) : receives the current text background color index.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQTXT") == 0) {
    printf("    PGQTXT -- find bounding box of text string\n");
    printf("\n");
    printf("\n");
    printf("void cpgqtxt(float x, float y, float angle, float fjust, \\n");
    printf(" const char *text, float *xbox, float *ybox);\n");
    printf("\n");
    printf("      SUBROUTINE PGQTXT (X, Y, ANGLE, FJUST, TEXT, XBOX, YBOX)\n");
    printf("      REAL X, Y, ANGLE, FJUST\n");
    printf("      CHARACTER*(*) TEXT\n");
    printf("      REAL XBOX(4), YBOX(4)\n");
    printf("\n");
    printf("This routine returns a bounding box for a text string. Instead\n");
    printf("of drawing the string as routine PGPTXT <#PGPTXT> does, it returns in XBOX\n");
    printf("and YBOX the coordinates of the corners of a rectangle parallel\n");
    printf("to the string baseline that just encloses the string. The four\n");
    printf("corners are in the order: lower left, upper left, upper right,\n");
    printf("lower right (where left and right refer to the first and last\n");
    printf("characters in the string).\n");
    printf("\n");
    printf("If the string is blank or contains no drawable characters, all\n");
    printf("four elements of XBOX and YBOX are assigned the starting point\n");
    printf("of the string, (X,Y).\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X, Y, ANGLE, FJUST, TEXT (input) : these arguments are the same as\n");
    printf("                   the corrresponding arguments in PGPTXT <#PGPTXT>.\n");
    printf(" XBOX, YBOX (output) : arrays of dimension 4; on output, they\n");
    printf("                   contain the world coordinates of the bounding\n");
    printf("                   box in (XBOX(1), YBOX(1)), ..., (XBOX(4), YBOX(4)).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQVP") == 0) {
    printf("    PGQVP -- inquire viewport size and position\n");
    printf("\n");
    printf("\n");
    printf("void cpgqvp(int units, float *x1, float *x2, float *y1, float *y2);\n");
    printf("\n");
    printf("      SUBROUTINE PGQVP (UNITS, X1, X2, Y1, Y2)\n");
    printf("      INTEGER UNITS\n");
    printf("      REAL    X1, X2, Y1, Y2\n");
    printf("\n");
    printf("Inquiry routine to determine the current viewport setting.\n");
    printf("The values returned may be normalized device coordinates, inches, mm,\n");
    printf("or pixels, depending on the value of the input parameter CFLAG.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" UNITS  (input)  : used to specify the units of the output parameters:\n");
    printf("                   UNITS = 0 : normalized device coordinates\n");
    printf("                   UNITS = 1 : inches\n");
    printf("                   UNITS = 2 : millimeters\n");
    printf("                   UNITS = 3 : pixels\n");
    printf("                   Other values give an error message, and are\n");
    printf("                   treated as 0.\n");
    printf(" X1     (output) : the x-coordinate of the bottom left corner of the\n");
    printf("                   viewport.\n");
    printf(" X2     (output) : the x-coordinate of the top right corner of the\n");
    printf("                   viewport.\n");
    printf(" Y1     (output) : the y-coordinate of the bottom left corner of the\n");
    printf("                   viewport.\n");
    printf(" Y2     (output) : the y-coordinate of the top right corner of the\n");
    printf("                   viewport.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQVSZ") == 0) {
    printf("    PGQVSZ -- inquire size of view surface\n");
    printf("\n");
    printf("\n");
    printf("void cpgqvsz(int units, float *x1, float *x2, float *y1, float *y2);\n");
    printf("\n");
    printf("      SUBROUTINE PGQVSZ (UNITS, X1, X2, Y1, Y2)\n");
    printf("      INTEGER UNITS\n");
    printf("      REAL X1, X2, Y1, Y2\n");
    printf("\n");
    printf("This routine returns the dimensions of the view surface (the maximum\n");
    printf("plottable area) of the currently selected graphics device, in \n");
    printf("a variety of units. The size of the view surface is device-dependent\n");
    printf("and is established when the graphics device is opened. On some \n");
    printf("devices, it can be changed by calling PGPAP <#PGPAP> before starting a new\n");
    printf("page with PGPAGE <#PGPAGE>. On some devices, the size can be changed (e.g.,\n");
    printf("by a workstation window manager) outside PGPLOT, and PGPLOT detects\n");
    printf("the change when PGPAGE <#PGPAGE> is used. Call this routine after PGPAGE to \n");
    printf("find the current size.\n");
    printf("\n");
    printf("Note 1: the width and the height of the view surface in normalized\n");
    printf("device coordinates are both always equal to 1.0.\n");
    printf("\n");
    printf("Note 2: when the device is divided into panels (see PGSUBP <#PGSUBP>), the\n");
    printf("view surface is a single panel.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" UNITS  (input)  : 0,1,2,3 for output in normalized device coords, \n");
    printf("                   inches, mm, or device units (pixels)\n");
    printf(" X1     (output) : always returns 0.0\n");
    printf(" X2     (output) : width of view surface\n");
    printf(" Y1     (output) : always returns 0.0\n");
    printf(" Y2     (output) : height of view surface\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGQWIN") == 0) {
    printf("    PGQWIN -- inquire window boundary coordinates\n");
    printf("\n");
    printf("\n");
    printf("void cpgqwin(float *x1, float *x2, float *y1, float *y2);\n");
    printf("\n");
    printf("      SUBROUTINE PGQWIN (X1, X2, Y1, Y2)\n");
    printf("      REAL X1, X2, Y1, Y2\n");
    printf("\n");
    printf("Inquiry routine to determine the current window setting.\n");
    printf("The values returned are world coordinates.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X1     (output) : the x-coordinate of the bottom left corner\n");
    printf("                   of the window.\n");
    printf(" X2     (output) : the x-coordinate of the top right corner\n");
    printf("                   of the window.\n");
    printf(" Y1     (output) : the y-coordinate of the bottom left corner\n");
    printf("                   of the window.\n");
    printf(" Y2     (output) : the y-coordinate of the top right corner\n");
    printf("                   of the window.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGRECT") == 0) {
    printf("    PGRECT -- draw a rectangle, using fill-area attributes\n");
    printf("\n");
    printf("\n");
    printf("void cpgrect(float x1, float x2, float y1, float y2);\n");
    printf("\n");
    printf("      SUBROUTINE PGRECT (X1, X2, Y1, Y2)\n");
    printf("      REAL X1, X2, Y1, Y2\n");
    printf("\n");
    printf("This routine can be used instead of PGPOLY <#PGPOLY> for the special case of\n");
    printf("drawing a rectangle aligned with the coordinate axes; only two\n");
    printf("vertices need be specified instead of four.  On most devices, it is\n");
    printf("faster to use PGRECT <#PGRECT> than PGPOLY <#PGPOLY> for drawing rectangles.  The\n");
    printf("rectangle has vertices at (X1,Y1), (X1,Y2), (X2,Y2), and (X2,Y1).\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X1, X2 (input) : the horizontal range of the rectangle.\n");
    printf(" Y1, Y2 (input) : the vertical range of the rectangle.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGRND") == 0) {
    printf("    PGRND -- find the smallest `round' number greater than x\n");
    printf("\n");
    printf("\n");
    printf("float cpgrnd(float x, int *nsub);\n");
    printf("\n");
    printf("      REAL FUNCTION PGRND (X, NSUB)\n");
    printf("      REAL X\n");
    printf("      INTEGER NSUB\n");
    printf("\n");
    printf("Routine to find the smallest \"round\" number larger than x, a\n");
    printf("\"round\" number being 1, 2 or 5 times a power of 10. If X is negative,\n");
    printf("PGRND <#PGRND>(X) = -PGRND(ABS(X)). eg PGRND(8.7) = 10.0,\n");
    printf("PGRND <#PGRND>(-0.4) = -0.5.  If X is zero, the value returned is zero.\n");
    printf("This routine is used by PGBOX <#PGBOX> for choosing  tick intervals.\n");
    printf("\n");
    printf("Returns:\n");
    printf(" PGRND <#PGRND>         : the \"round\" number.\n");
    printf("Arguments:\n");
    printf(" X      (input)  : the number to be rounded.\n");
    printf(" NSUB   (output) : a suitable number of subdivisions for\n");
    printf("                   subdividing the \"nice\" number: 2 or 5.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGRNGE") == 0) {
    printf("    PGRNGE -- choose axis limits\n");
    printf("\n");
    printf("\n");
    printf("void cpgrnge(float x1, float x2, float *xlo, float *xhi);\n");
    printf("\n");
    printf("      SUBROUTINE PGRNGE (X1, X2, XLO, XHI)\n");
    printf("      REAL X1, X2, XLO, XHI\n");
    printf("\n");
    printf("Choose plotting limits XLO and XHI which encompass the data\n");
    printf("range X1 to X2.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X1, X2 (input)  : the data range (X1<X2), ie, the min and max values\n");
    printf("                   to be plotted.\n");
    printf(" XLO, XHI (output) : suitable values to use as the extremes of a graph\n");
    printf("                   axis (XLO <= X1, XHI >= X2).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSAH") == 0) {
    printf("    PGSAH -- set arrow-head style\n");
    printf("\n");
    printf("\n");
    printf("void cpgsah(int fs, float angle, float barb);\n");
    printf("\n");
    printf("      SUBROUTINE PGSAH (FS, ANGLE, BARB)\n");
    printf("      INTEGER  FS\n");
    printf("      REAL ANGLE, BARB\n");
    printf("\n");
    printf("Set the style to be used for arrowheads drawn with routine PGARRO <#PGARRO>.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" FS     (input)  : FS = 1 => filled; FS = 2 => outline.\n");
    printf("                   Other values are treated as 2. Default 1.\n");
    printf(" ANGLE  (input)  : the acute angle of the arrow point, in degrees;\n");
    printf("                   angles in the range 20.0 to 90.0 give reasonable\n");
    printf("                   results. Default 45.0.\n");
    printf(" BARB   (input)  : the fraction of the triangular arrow-head that\n");
    printf("                   is cut away from the back. 0.0 gives a triangular\n");
    printf("                   wedge arrow-head; 1.0 gives an open >. Values 0.3\n");
    printf("                   to 0.7 give reasonable results. Default 0.3.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSAVE") == 0) {
    printf("    PGSAVE -- save PGPLOT attributes\n");
    printf("\n");
    printf("\n");
    printf("void cpgsave(void);\n");
    printf("\n");
    printf("      SUBROUTINE PGSAVE\n");
    printf("\n");
    printf("This routine saves the current PGPLOT attributes in a private storage\n");
    printf("area. They can be restored by calling PGUNSA <#PGUNSA> (unsave). Attributes\n");
    printf("saved are: character font, character height, color index, fill-area\n");
    printf("style, line style, line width, pen position, arrow-head style, \n");
    printf("hatching style, and clipping state. Color representation is not saved.\n");
    printf("\n");
    printf("Calls to PGSAVE <#PGSAVE> and PGUNSA <#PGUNSA> should always be paired. Up to 20 copies\n");
    printf("of the attributes may be saved. PGUNSA <#PGUNSA> always retrieves the last-saved\n");
    printf("values (last-in first-out stack).\n");
    printf("\n");
    printf("Note that when multiple devices are in use, PGUNSA <#PGUNSA> retrieves the\n");
    printf("values saved by the last PGSAVE <#PGSAVE> call, even if they were for a\n");
    printf("different device.\n");
    printf("\n");
    printf("Arguments: none\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGUNSA") == 0) {
    printf("    PGUNSA -- restore PGPLOT attributes\n");
    printf("\n");
    printf("\n");
    printf("void cpgunsa(void);\n");
    printf("\n");
    printf("      ENTRY PGUNSA\n");
    printf("\n");
    printf("This routine restores the PGPLOT attributes saved in the last call to\n");
    printf("PGSAVE <#PGSAVE>. Usage: CALL PGUNSA <#PGUNSA> (no arguments). See PGSAVE.\n");
    printf("\n");
    printf("Arguments: none\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSCF") == 0) {
    printf("    PGSCF -- set character font\n");
    printf("\n");
    printf("\n");
    printf("void cpgscf(int font);\n");
    printf("\n");
    printf("      SUBROUTINE PGSCF (FONT)\n");
    printf("      INTEGER  FONT\n");
    printf("\n");
    printf("Set the Character Font for subsequent text plotting. Four different\n");
    printf("fonts are available:\n");
    printf("  1: (default) a simple single-stroke font (\"normal\" font)\n");
    printf("  2: roman font\n");
    printf("  3: italic font\n");
    printf("  4: script font\n");
    printf("This call determines which font is in effect at the beginning of\n");
    printf("each text string. The font can be changed (temporarily) within a text\n");
    printf("string by using the escape sequences \fn, \fr, \fi, and \fs for fonts\n");
    printf("1, 2, 3, and 4, respectively.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" FONT   (input)  : the font number to be used for subsequent text\n");
    printf("                   plotting (in range 1-4).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSCH") == 0) {
    printf("    PGSCH -- set character height\n");
    printf("\n");
    printf("\n");
    printf("void cpgsch(float size);\n");
    printf("\n");
    printf("      SUBROUTINE PGSCH (SIZE)\n");
    printf("      REAL SIZE\n");
    printf("\n");
    printf("Set the character size attribute. The size affects all text and graph\n");
    printf("markers drawn later in the program. The default character size is\n");
    printf("1.0, corresponding to a character height about 1/40 the height of\n");
    printf("the view surface.  Changing the character size also scales the length\n");
    printf("of tick marks drawn by PGBOX <#PGBOX> and terminals drawn by PGERRX <#PGERRX> and PGERRY <#PGERRY>.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" SIZE   (input)  : new character size (dimensionless multiple of\n");
    printf("                   the default size).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSCI") == 0) {
    printf("    PGSCI -- set color index\n");
    printf("\n");
    printf("\n");
    printf("void cpgsci(int ci);\n");
    printf("\n");
    printf("      SUBROUTINE PGSCI (CI)\n");
    printf("      INTEGER  CI\n");
    printf("\n");
    printf("Set the Color Index for subsequent plotting, if the output device\n");
    printf("permits this. The default color index is 1, usually white on a black\n");
    printf("background for video displays or black on a white background for\n");
    printf("printer plots. The color index is an integer in the range 0 to a\n");
    printf("device-dependent maximum. Color index 0 corresponds to the background\n");
    printf("color; lines may be \"erased\" by overwriting them with color index 0\n");
    printf("(if the device permits this).\n");
    printf("\n");
    printf("If the requested color index is not available on the selected device,\n");
    printf("color index 1 will be substituted.\n");
    printf("\n");
    printf("The assignment of colors to color indices can be changed with\n");
    printf("subroutine PGSCR <#PGSCR> (set color representation).  Color indices 0-15\n");
    printf("have predefined color representations (see the PGPLOT manual), but\n");
    printf("these may be changed with PGSCR <#PGSCR>.  Color indices above 15  have no\n");
    printf("predefined representations: if these indices are used, PGSCR <#PGSCR> must\n");
    printf("be called to define the representation.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" CI     (input)  : the color index to be used for subsequent plotting\n");
    printf("                   on the current device (in range 0-max). If the\n");
    printf("                   index exceeds the device-dependent maximum, the\n");
    printf("                   default color index (1) is used.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSCIR") == 0) {
    printf("    PGSCIR -- set color index range\n");
    printf("\n");
    printf("\n");
    printf("void cpgscir(int icilo, int icihi);\n");
    printf("\n");
    printf("      SUBROUTINE PGSCIR(ICILO, ICIHI)\n");
    printf("      INTEGER   ICILO, ICIHI\n");
    printf("\n");
    printf("Set the color index range to be used for producing images with\n");
    printf("PGGRAY <#PGGRAY> or PGIMAG <#PGIMAG>. If the range is not all within the range supported\n");
    printf("by the device, a smaller range will be used. The number of\n");
    printf("different colors available for images is ICIHI-ICILO+1.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" ICILO  (input)  : the lowest color index to use for images\n");
    printf(" ICIHI  (input)  : the highest color index to use for images\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSCLP") == 0) {
    printf("    PGSCLP -- enable or disable clipping at edge of viewport\n");
    printf("\n");
    printf("\n");
    printf("void cpgsclp(int state);\n");
    printf("\n");
    printf("      SUBROUTINE PGSCLP(STATE)\n");
    printf("      INTEGER STATE\n");
    printf("\n");
    printf("Normally all PGPLOT primitives except text are ``clipped'' at the\n");
    printf("edge of the viewport: parts of the primitives that lie outside\n");
    printf("the viewport are not drawn. If clipping is disabled by calling this\n");
    printf("routine, primitives are visible wherever they lie on the view\n");
    printf("surface. The default (clipping enabled) is appropriate for almost\n");
    printf("all applications.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" STATE  (input)  : 0 to disable clipping, or 1 to enable clipping.\n");
    printf("\n");
    printf("25-Feb-1997 [TJP] - new routine.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSCR") == 0) {
    printf("    PGSCR -- set color representation\n");
    printf("\n");
    printf("\n");
    printf("void cpgscr(int ci, float cr, float cg, float cb);\n");
    printf("\n");
    printf("      SUBROUTINE PGSCR (CI, CR, CG, CB)\n");
    printf("      INTEGER CI\n");
    printf("      REAL    CR, CG, CB\n");
    printf("\n");
    printf("Set color representation: i.e., define the color to be\n");
    printf("associated with a color index.  Ignored for devices which do not\n");
    printf("support variable color or intensity.  Color indices 0-15\n");
    printf("have predefined color representations (see the PGPLOT manual), but\n");
    printf("these may be changed with PGSCR <#PGSCR>.  Color indices 16-maximum have no\n");
    printf("predefined representations: if these indices are used, PGSCR <#PGSCR> must\n");
    printf("be called to define the representation. On monochrome output\n");
    printf("devices (e.g. VT125 terminals with monochrome monitors), the\n");
    printf("monochrome intensity is computed from the specified Red, Green, Blue\n");
    printf("intensities as 0.30*R + 0.59*G + 0.11*B, as in US color television\n");
    printf("systems, NTSC encoding.  Note that most devices do not have an\n");
    printf("infinite range of colors or monochrome intensities available;\n");
    printf("the nearest available color is used.  Examples: for black,\n");
    printf("set CR=CG=CB=0.0; for white, set CR=CG=CB=1.0; for medium gray,\n");
    printf("set CR=CG=CB=0.5; for medium yellow, set CR=CG=0.5, CB=0.0.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" CI     (input)  : the color index to be defined, in the range 0-max.\n");
    printf("                   If the color index greater than the device\n");
    printf("                   maximum is specified, the call is ignored. Color\n");
    printf("                   index 0 applies to the background color.\n");
    printf(" CR     (input)  : red, green, and blue intensities,\n");
    printf(" CG     (input)    in range 0.0 to 1.0.\n");
    printf(" CB     (input)\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSCRL") == 0) {
    printf("    PGSCRL -- scroll window\n");
    printf("\n");
    printf("\n");
    printf("void cpgscrl(float dx, float dy);\n");
    printf("\n");
    printf("      SUBROUTINE PGSCRL (DX, DY)\n");
    printf("      REAL DX, DY\n");
    printf("\n");
    printf("This routine moves the window in world-coordinate space while\n");
    printf("leaving the viewport unchanged. On devices that have the\n");
    printf("capability, the pixels within the viewport are scrolled\n");
    printf("horizontally, vertically or both in such a way that graphics\n");
    printf("previously drawn in the window are shifted so that their world\n");
    printf("coordinates are unchanged.\n");
    printf("\n");
    printf("If the old window coordinate range was (X1, X2, Y1, Y2), the new\n");
    printf("coordinate range will be approximately (X1+DX, X2+DX, Y1+DY, Y2+DY).\n");
    printf("The size and scale of the window are unchanged.\n");
    printf("\n");
    printf("Thee window can only be shifted by a whole number of pixels\n");
    printf("(device coordinates). If DX and DY do not correspond to integral\n");
    printf("numbers of pixels, the shift will be slightly different from that\n");
    printf("requested. The new window-coordinate range, and hence the exact\n");
    printf("amount of the shift, can be determined by calling PGQWIN <#PGQWIN> after this\n");
    printf("routine.\n");
    printf("\n");
    printf("Pixels that are moved out of the viewport by this operation are\n");
    printf("lost completely; they cannot be recovered by scrolling back.\n");
    printf("Pixels that are ``scrolled into'' the viewport are filled with\n");
    printf("the background color (color index 0).\n");
    printf("\n");
    printf("If the absolute value of DX is bigger than the width of the window,\n");
    printf("or the aboslute value of DY is bigger than the height of the window,\n");
    printf("the effect will be the same as zeroing all the pixels in the\n");
    printf("viewport.\n");
    printf("\n");
    printf("Not all devices have the capability to support this routine.\n");
    printf("It is only available on some interactive devices that have discrete\n");
    printf("pixels. To determine whether the current device has scroll capability,\n");
    printf("call PGQINF <#PGQINF>.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" DX     (input)  : distance (in world coordinates) to shift the\n");
    printf("                   window horizontally (positive shifts window to the\n");
    printf("                   right and scrolls to the left).\n");
    printf(" DY     (input)  : distance (in world coordinates) to shift the\n");
    printf("                   window vertically (positive shifts window up and\n");
    printf("                   scrolls down).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSCRN") == 0) {
    printf("    PGSCRN -- set color representation by name\n");
    printf("\n");
    printf("\n");
    printf("void cpgscrn(int ci, const char *name, int *ier);\n");
    printf("\n");
    printf("      SUBROUTINE PGSCRN(CI, NAME, IER)\n");
    printf("      INTEGER CI\n");
    printf("      CHARACTER*(*) NAME\n");
    printf("      INTEGER IER\n");
    printf("\n");
    printf("Set color representation: i.e., define the color to be\n");
    printf("associated with a color index.  Ignored for devices which do not\n");
    printf("support variable color or intensity.  This is an alternative to\n");
    printf("routine PGSCR <#PGSCR>. The color representation is defined by name instead\n");
    printf("of (R,G,B) components.\n");
    printf("\n");
    printf("Color names are defined in an external file which is read the first\n");
    printf("time that PGSCRN <#PGSCRN> is called. The name of the external file is\n");
    printf("found as follows:\n");
    printf("1. if environment variable (logical name) PGPLOT_RGB is defined,\n");
    printf("   its value is used as the file name;\n");
    printf("2. otherwise, if environment variable PGPLOT_DIR is defined, a\n");
    printf("   file \"rgb.txt\" in the directory named by this environment\n");
    printf("   variable is used;\n");
    printf("3. otherwise, file \"rgb.txt\" in the current directory is used.\n");
    printf("If all of these fail to find a file, an error is reported and\n");
    printf("the routine does nothing.\n");
    printf("\n");
    printf("Each line of the file\n");
    printf("defines one color, with four blank- or tab-separated fields per\n");
    printf("line. The first three fields are the R, G, B components, which\n");
    printf("are integers in the range 0 (zero intensity) to 255 (maximum\n");
    printf("intensity). The fourth field is the color name. The color name\n");
    printf("may include embedded blanks. Example:\n");
    printf("\n");
    printf("255   0   0 red\n");
    printf("255 105 180 hot pink\n");
    printf("255 255 255 white\n");
    printf("  0   0   0 black\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" CI     (input)  : the color index to be defined, in the range 0-max.\n");
    printf("                   If the color index greater than the device\n");
    printf("                   maximum is specified, the call is ignored. Color\n");
    printf("                   index 0 applies to the background color.\n");
    printf(" NAME   (input)  : the name of the color to be associated with\n");
    printf("                   this color index. This name must be in the\n");
    printf("                   external file. The names are not case-sensitive.\n");
    printf("                   If the color is not listed in the file, the\n");
    printf("                   color representation is not changed.\n");
    printf(" IER    (output) : returns 0 if the routine was successful, 1\n");
    printf("                   if an error occurred (either the external file\n");
    printf("                   could not be read, or the requested color was\n");
    printf("                   not defined in the file).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSFS") == 0) {
    printf("    PGSFS -- set fill-area style\n");
    printf("\n");
    printf("\n");
    printf("void cpgsfs(int fs);\n");
    printf("\n");
    printf("      SUBROUTINE PGSFS (FS)\n");
    printf("      INTEGER  FS\n");
    printf("\n");
    printf("Set the Fill-Area Style attribute for subsequent area-fill by\n");
    printf("PGPOLY <#PGPOLY>, PGRECT <#PGRECT>, or PGCIRC <#PGCIRC>.  Four different styles are available: \n");
    printf("solid (fill polygon with solid color of the current color-index), \n");
    printf("outline (draw outline of polygon only, using current line attributes),\n");
    printf("hatched (shade interior of polygon with parallel lines, using\n");
    printf("current line attributes), or cross-hatched. The orientation and\n");
    printf("spacing of hatch lines can be specified with routine PGSHS <#PGSHS> (set\n");
    printf("hatch style).\n");
    printf("\n");
    printf("Argument:\n");
    printf(" FS     (input)  : the fill-area style to be used for subsequent\n");
    printf("                   plotting:\n");
    printf("                     FS = 1 => solid (default)\n");
    printf("                     FS = 2 => outline\n");
    printf("                     FS = 3 => hatched\n");
    printf("                     FS = 4 => cross-hatched\n");
    printf("                   Other values give an error message and are\n");
    printf("                   treated as 2.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSHLS") == 0) {
    printf("    PGSHLS -- set color representation using HLS system\n");
    printf("\n");
    printf("\n");
    printf("void cpgshls(int ci, float ch, float cl, float cs);\n");
    printf("\n");
    printf("      SUBROUTINE PGSHLS (CI, CH, CL, CS)\n");
    printf("      INTEGER CI\n");
    printf("      REAL    CH, CL, CS\n");
    printf("\n");
    printf("Set color representation: i.e., define the color to be\n");
    printf("associated with a color index.  This routine is equivalent to\n");
    printf("PGSCR <#PGSCR>, but the color is defined in the Hue-Lightness-Saturation\n");
    printf("model instead of the Red-Green-Blue model. Hue is represented\n");
    printf("by an angle in degrees, with red at 120, green at 240,\n");
    printf("and blue at 0 (or 360). Lightness ranges from 0.0 to 1.0, with black\n");
    printf("at lightness 0.0 and white at lightness 1.0. Saturation ranges from\n");
    printf("0.0 (gray) to 1.0 (pure color). Hue is irrelevant when saturation\n");
    printf("is 0.0.\n");
    printf("\n");
    printf("Examples:           H     L     S        R     G     B\n");
    printf("    black          any   0.0   0.0      0.0   0.0   0.0\n");
    printf("    white          any   1.0   0.0      1.0   1.0   1.0\n");
    printf("    medium gray    any   0.5   0.0      0.5   0.5   0.5\n");
    printf("    red            120   0.5   1.0      1.0   0.0   0.0\n");
    printf("    yellow         180   0.5   1.0      1.0   1.0   0.0\n");
    printf("    pink           120   0.7   0.8      0.94  0.46  0.46\n");
    printf("\n");
    printf("Reference: SIGGRAPH Status Report of the Graphic Standards Planning\n");
    printf("Committee, Computer Graphics, Vol.13, No.3, Association for\n");
    printf("Computing Machinery, New York, NY, 1979. See also: J. D. Foley et al,\n");
    printf("``Computer Graphics: Principles and Practice'', second edition,\n");
    printf("Addison-Wesley, 1990, section 13.3.5.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" CI     (input)  : the color index to be defined, in the range 0-max.\n");
    printf("                   If the color index greater than the device\n");
    printf("                   maximum is specified, the call is ignored. Color\n");
    printf("                   index 0 applies to the background color.\n");
    printf(" CH     (input)  : hue, in range 0.0 to 360.0.\n");
    printf(" CL     (input)  : lightness, in range 0.0 to 1.0.\n");
    printf(" CS     (input)  : saturation, in range 0.0 to 1.0.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSHS") == 0) {
    printf("    PGSHS -- set hatching style\n");
    printf("\n");
    printf("\n");
    printf("void cpgshs(float angle, float sepn, float phase);\n");
    printf("\n");
    printf("      SUBROUTINE PGSHS (ANGLE, SEPN, PHASE)\n");
    printf("      REAL ANGLE, SEPN, PHASE\n");
    printf("\n");
    printf("Set the style to be used for hatching (fill area with fill-style 3).\n");
    printf("The default style is ANGLE=45.0, SEPN=1.0, PHASE=0.0.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" ANGLE  (input)  : the angle the hatch lines make with the\n");
    printf("                   horizontal, in degrees, increasing \n");
    printf("                   counterclockwise (this is an angle on the\n");
    printf("                   view surface, not in world-coordinate space).\n");
    printf(" SEPN   (input)  : the spacing of the hatch lines. The unit spacing\n");
    printf("                   is 1 percent of the smaller of the height or\n");
    printf("                   width of the view surface. This should not be\n");
    printf("                   zero.\n");
    printf(" PHASE  (input)  : a real number between 0 and 1; the hatch lines\n");
    printf("                   are displaced by this fraction of SEPN from a\n");
    printf("                   fixed reference.  Adjacent regions hatched with the\n");
    printf("                   same PHASE have contiguous hatch lines. To hatch\n");
    printf("                   a region with alternating lines of two colors,\n");
    printf("                   fill the area twice, with PHASE=0.0 for one color\n");
    printf("                   and PHASE=0.5 for the other color.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSITF") == 0) {
    printf("    PGSITF -- set image transfer function\n");
    printf("\n");
    printf("\n");
    printf("void cpgsitf(int itf);\n");
    printf("\n");
    printf("      SUBROUTINE PGSITF (ITF)\n");
    printf("      INTEGER  ITF\n");
    printf("\n");
    printf("Set the Image Transfer Function for subsequent images drawn by\n");
    printf("PGIMAG <#PGIMAG>, PGGRAY <#PGGRAY>, or PGWEDG <#PGWEDG>. The Image Transfer Function is used\n");
    printf("to map array values into the available range of color indices\n");
    printf("specified with routine PGSCIR <#PGSCIR> or (for PGGRAY <#PGGRAY> on some devices)\n");
    printf("into dot density.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" ITF    (input)  : type of transfer function:\n");
    printf("                     ITF = 0 : linear\n");
    printf("                     ITF = 1 : logarithmic\n");
    printf("                     ITF = 2 : square-root\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSLCT") == 0) {
    printf("    PGSLCT -- select an open graphics device\n");
    printf("\n");
    printf("\n");
    printf("void cpgslct(int id);\n");
    printf("\n");
    printf("      SUBROUTINE PGSLCT(ID)\n");
    printf("      INTEGER ID\n");
    printf("\n");
    printf("Select one of the open graphics devices and direct subsequent\n");
    printf("plotting to it. The argument is the device identifier returned by\n");
    printf("PGOPEN <#PGOPEN> when the device was opened. If the supplied argument is not a\n");
    printf("valid identifier of an open graphics device, a warning message is\n");
    printf("issued and the current selection is unchanged.\n");
    printf("\n");
    printf("[This routine was added to PGPLOT in Version 5.1.0.]\n");
    printf("\n");
    printf("Arguments:\n");
    printf("\n");
    printf("ID (input, integer): identifier of the device to be selected.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSLS") == 0) {
    printf("    PGSLS -- set line style\n");
    printf("\n");
    printf("\n");
    printf("void cpgsls(int ls);\n");
    printf("\n");
    printf("      SUBROUTINE PGSLS (LS)\n");
    printf("      INTEGER  LS\n");
    printf("\n");
    printf("Set the line style attribute for subsequent plotting. This\n");
    printf("attribute affects line primitives only; it does not affect graph\n");
    printf("markers, text, or area fill.\n");
    printf("Five different line styles are available, with the following codes:\n");
    printf("1 (full line), 2 (dashed), 3 (dot-dash-dot-dash), 4 (dotted),\n");
    printf("5 (dash-dot-dot-dot). The default is 1 (normal full line).\n");
    printf("\n");
    printf("Argument:\n");
    printf(" LS     (input)  : the line-style code for subsequent plotting\n");
    printf("                   (in range 1-5).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSLW") == 0) {
    printf("    PGSLW -- set line width\n");
    printf("\n");
    printf("\n");
    printf("void cpgslw(int lw);\n");
    printf("\n");
    printf("      SUBROUTINE PGSLW (LW)\n");
    printf("      INTEGER  LW\n");
    printf("\n");
    printf("Set the line-width attribute. This attribute affects lines, graph\n");
    printf("markers, and text. The line width is specified in units of 1/200 \n");
    printf("(0.005) inch (about 0.13 mm) and must be an integer in the range\n");
    printf("1-201. On some devices, thick lines are generated by tracing each\n");
    printf("line with multiple strokes offset in the direction perpendicular to\n");
    printf("the line.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" LW     (input)  : width of line, in units of 0.005 inch (0.13 mm)\n");
    printf("                   in range 1-201.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSTBG") == 0) {
    printf("    PGSTBG -- set text background color index\n");
    printf("\n");
    printf("\n");
    printf("void cpgstbg(int tbci);\n");
    printf("\n");
    printf("      SUBROUTINE PGSTBG (TBCI)\n");
    printf("      INTEGER  TBCI\n");
    printf("\n");
    printf("Set the Text Background Color Index for subsequent text. By default\n");
    printf("text does not obscure underlying graphics. If the text background\n");
    printf("color index is positive, however, text is opaque: the bounding box\n");
    printf("of the text is filled with the color specified by PGSTBG <#PGSTBG> before\n");
    printf("drawing the text characters in the current color index set by PGSCI <#PGSCI>.\n");
    printf("Use color index 0 to erase underlying graphics before drawing text.\n");
    printf("\n");
    printf("Argument:\n");
    printf(" TBCI   (input)  : the color index to be used for the background\n");
    printf("                   for subsequent text plotting:\n");
    printf("                     TBCI < 0  => transparent (default)\n");
    printf("                     TBCI >= 0 => text will be drawn on an opaque\n");
    printf("                   background with color index TBCI.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSUBP") == 0) {
    printf("    PGSUBP -- subdivide view surface into panels\n");
    printf("\n");
    printf("\n");
    printf("void cpgsubp(int nxsub, int nysub);\n");
    printf("\n");
    printf("      SUBROUTINE PGSUBP (NXSUB, NYSUB)\n");
    printf("      INTEGER NXSUB, NYSUB\n");
    printf("\n");
    printf("PGPLOT divides the physical surface of the plotting device (screen,\n");
    printf("window, or sheet of paper) into NXSUB x NYSUB `panels'. When the \n");
    printf("view surface is sub-divided in this way, PGPAGE <#PGPAGE> moves to the next\n");
    printf("panel, not the next physical page. The initial subdivision of the\n");
    printf("view surface is set in the call to PGBEG <#PGBEG>. When PGSUBP <#PGSUBP> is called,\n");
    printf("it forces the next call to PGPAGE <#PGPAGE> to start a new physical page,\n");
    printf("subdivided in the manner indicated. No plotting should be done\n");
    printf("between a call of PGSUBP <#PGSUBP> and a call of PGPAGE <#PGPAGE> (or PGENV <#PGENV>, which calls\n");
    printf("PGPAGE <#PGPAGE>).\n");
    printf("\n");
    printf("If NXSUB > 0, PGPLOT uses the panels in row order; if <0, \n");
    printf("PGPLOT uses them in column order, e.g.,\n");
    printf("     \n");
    printf(" NXSUB=3, NYSUB=2            NXSUB=-3, NYSUB=2   \n");
    printf("                                               \n");
    printf("+-----+-----+-----+         +-----+-----+-----+\n");
    printf("|  1  |  2  |  3  |         |  1  |  3  |  5  |\n");
    printf("+-----+-----+-----+         +-----+-----+-----+\n");
    printf("|  4  |  5  |  6  |         |  2  |  4  |  6  |\n");
    printf("+-----+-----+-----+         +-----+-----+-----+\n");
    printf("\n");
    printf("PGPLOT advances from one panels to the next when PGPAGE <#PGPAGE> is called,\n");
    printf("clearing the screen or starting a new page when the last panel has\n");
    printf("been used. It is also possible to jump from one panel to another\n");
    printf("in random order by calling PGPANL <#PGPANL>.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" NXSUB  (input)  : the number of subdivisions of the view surface in\n");
    printf("                   X (>0 or <0).\n");
    printf(" NYSUB  (input)  : the number of subdivisions of the view surface in\n");
    printf("                   Y (>0).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSVP") == 0) {
    printf("    PGSVP -- set viewport (normalized device coordinates)\n");
    printf("\n");
    printf("\n");
    printf("void cpgsvp(float xleft, float xright, float ybot, float ytop);\n");
    printf("\n");
    printf("      SUBROUTINE PGSVP (XLEFT, XRIGHT, YBOT, YTOP)\n");
    printf("      REAL XLEFT, XRIGHT, YBOT, YTOP\n");
    printf("\n");
    printf("Change the size and position of the viewport, specifying\n");
    printf("the viewport in normalized device coordinates.  Normalized\n");
    printf("device coordinates run from 0 to 1 in each dimension. The\n");
    printf("viewport is the rectangle on the view surface \"through\"\n");
    printf("which one views the graph.  All the PG routines which plot lines\n");
    printf("etc. plot them within the viewport, and lines are truncated at\n");
    printf("the edge of the viewport (except for axes, labels etc drawn with\n");
    printf("PGBOX <#PGBOX> or PGLAB <#PGLAB>).  The region of world space (the coordinate\n");
    printf("space of the graph) which is visible through the viewport is\n");
    printf("specified by a call to PGSWIN <#PGSWIN>.  It is legal to request a\n");
    printf("viewport larger than the view surface; only the part which\n");
    printf("appears on the view surface will be plotted.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" XLEFT  (input)  : x-coordinate of left hand edge of viewport, in NDC.\n");
    printf(" XRIGHT (input)  : x-coordinate of right hand edge of viewport,\n");
    printf("                   in NDC.\n");
    printf(" YBOT   (input)  : y-coordinate of bottom edge of viewport, in NDC.\n");
    printf(" YTOP   (input)  : y-coordinate of top  edge of viewport, in NDC.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGSWIN") == 0) {
    printf("    PGSWIN -- set window\n");
    printf("\n");
    printf("\n");
    printf("void cpgswin(float x1, float x2, float y1, float y2);\n");
    printf("\n");
    printf("      SUBROUTINE PGSWIN (X1, X2, Y1, Y2)\n");
    printf("      REAL X1, X2, Y1, Y2\n");
    printf("\n");
    printf("Change the window in world coordinate space that is to be mapped on\n");
    printf("to the viewport.  Usually PGSWIN <#PGSWIN> is called automatically by PGENV <#PGENV>,\n");
    printf("but it may be called directly by the user.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X1     (input)  : the x-coordinate of the bottom left corner\n");
    printf("                   of the viewport.\n");
    printf(" X2     (input)  : the x-coordinate of the top right corner\n");
    printf("                   of the viewport (note X2 may be less than X1).\n");
    printf(" Y1     (input)  : the y-coordinate of the bottom left corner\n");
    printf("                   of the viewport.\n");
    printf(" Y2     (input)  : the y-coordinate of the top right corner\n");
    printf("                   of the viewport (note Y2 may be less than Y1).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGTBOX") == 0) {
    printf("    PGTBOX -- draw frame and write (DD) HH MM SS.S labelling\n");
    printf("\n");
    printf("\n");
    printf("void cpgtbox(const char *xopt, float xtick, int nxsub, \\n");
    printf(" const char *yopt, float ytick, int nysub);\n");
    printf("\n");
    printf("      SUBROUTINE PGTBOX (XOPT, XTICK, NXSUB, YOPT, YTICK, NYSUB)\n");
    printf("\n");
    printf("      REAL XTICK, YTICK\n");
    printf("      INTEGER NXSUB, NYSUB\n");
    printf("      CHARACTER XOPT*(*), YOPT*(*)\n");
    printf("\n");
    printf("Draw a box and optionally label one or both axes with (DD) HH MM SS \n");
    printf("style numeric labels (useful for time or RA - DEC plots).   If this \n");
    printf("style of labelling is desired, then PGSWIN <#PGSWIN> should have been called\n");
    printf("previously with the extrema in SECONDS of time.\n");
    printf("\n");
    printf("In the seconds field, you can have at most 3 places after the decimal\n");
    printf("point, so that 1 ms is the smallest time interval you can time label.\n");
    printf("\n");
    printf("Large numbers are coped with by fields of 6 characters long.  Thus \n");
    printf("you could have times with days or hours as big as 999999.  However, \n");
    printf("in practice, you might have trouble with labels overwriting  themselves\n");
    printf("with such large numbers unless you a) use a small time INTERVAL, \n");
    printf("b) use a small character size or c) choose your own sparse ticks in \n");
    printf("the call to PGTBOX <#PGTBOX>.  \n");
    printf("\n");
    printf("PGTBOX <#PGTBOX> will attempt, when choosing its own ticks, not to overwrite\n");
    printf("the labels, but this algorithm is not very bright and may fail.\n");
    printf("\n");
    printf("Note that small intervals but large absolute times such as\n");
    printf("TMIN = 200000.0 s and TMAX=200000.1 s will cause the algorithm\n");
    printf("to fail.  This is inherent in PGPLOT's use of single precision\n");
    printf("and cannot be avoided.  In such cases, you should use relative\n");
    printf("times if possible.\n");
    printf("\n");
    printf("PGTBOX <#PGTBOX>'s labelling philosophy is that the left-most or bottom tick of\n");
    printf("the axis contains a full label.  Thereafter, only changing fields are\n");
    printf("labelled.  Negative fields are given a '-' label, positive fields\n");
    printf("have none.   Axes that have the DD (or HH if the day field is not\n");
    printf("used) field on each major tick carry the sign on each field.  If the\n");
    printf("axis crosses zero, the zero tick will carry a full label and sign.\n");
    printf("\n");
    printf("This labelling style can cause a little confusion with some special\n");
    printf("cases, but as long as you know its philosophy, the truth can be divined.\n");
    printf("Consider an axis with TMIN=20s, TMAX=-20s.   The labels will look like\n");
    printf("\n");
    printf("       +----------+----------+----------+----------+\n");
    printf("    0h0m20s      10s      -0h0m0s      10s        20s\n");
    printf("\n");
    printf("Knowing that the left field always has a full label and that\n");
    printf("positive fields are unsigned, informs that time is decreasing\n");
    printf("from left to right, not vice versa.   This can become very \n");
    printf("unclear if you have used the 'F' option, but that is your problem !\n");
    printf("\n");
    printf("Exceptions to this labelling philosophy are when the finest time\n");
    printf("increment being displayed is hours (with option 'Y') or days.  \n");
    printf("Then all fields carry a label.  For example,\n");
    printf("\n");
    printf("       +----------+----------+----------+----------+\n");
    printf("     -10h        -8h        -6h        -4h        -2h\n");
    printf("\n");
    printf("\n");
    printf("PGTBOX <#PGTBOX> can be used in place of PGBOX <#PGBOX>; it calls PGBOX and only invokes \n");
    printf("time labelling if requested. Other options are passed intact to PGBOX <#PGBOX>.\n");
    printf("\n");
    printf("Inputs:\n");
    printf(" XOPT   :  X-options for PGTBOX <#PGTBOX>.  Same as for PGBOX <#PGBOX> plus \n");
    printf("\n");
    printf("            'Z' for (DD) HH MM SS.S time labelling\n");
    printf("            'Y' means don't include the day field so that labels\n");
    printf("                are HH MM SS.S rather than DD HH MM SS.S   The hours\n");
    printf("                will accumulate beyond 24 if necessary in this case.\n");
    printf("            'X' label the HH field as modulo 24.  Thus, a label\n");
    printf("                such as 25h 10m would come out as 1h 10m\n");
    printf("            'H' means superscript numbers with d, h, m, & s  symbols\n");
    printf("            'D' means superscript numbers with    o, ', & '' symbols \n");
    printf("            'F' causes the first label (left- or bottom-most) to\n");
    printf("                be omitted. Useful for sub-panels that abut each other.\n");
    printf("                Care is needed because first label carries sign as well.\n");
    printf("            'O' means omit leading zeros in numbers < 10\n");
    printf("                E.g.  3h 3m 1.2s rather than 03h 03m 01.2s  Useful\n");
    printf("                to help save space on X-axes. The day field does not \n");
    printf("                use this facility.\n");
    printf("\n");
    printf(" YOPT   :  Y-options for PGTBOX <#PGTBOX>.  See above.\n");
    printf(" XTICK  :  X-axis major tick increment.  0.0 for default. \n");
    printf(" YTICK  :  Y-axis major tick increment.  0.0 for default. \n");
    printf("           If the 'Z' option is used then XTICK and/or YTICK must\n");
    printf("           be in seconds.\n");
    printf(" NXSUB  :  Number of intervals for minor ticks on X-axis. 0 for default\n");
    printf(" NYSUB  :  Number of intervals for minor ticks on Y-axis. 0 for default\n");
    printf("\n");
    printf(" The regular XOPT and YOPT axis options for PGBOX <#PGBOX> are\n");
    printf("\n");
    printf(" A : draw Axis (X axis is horizontal line Y=0, Y axis is vertical\n");
    printf("     line X=0).\n");
    printf(" B : draw bottom (X) or left (Y) edge of frame.\n");
    printf(" C : draw top (X) or right (Y) edge of frame.\n");
    printf(" G : draw Grid of vertical (X) or horizontal (Y) lines.\n");
    printf(" I : Invert the tick marks; ie draw them outside the viewport\n");
    printf("     instead of inside.\n");
    printf(" L : label axis Logarithmically (see below).\n");
    printf(" N : write Numeric labels in the conventional location below the\n");
    printf("     viewport (X) or to the left of the viewport (Y).\n");
    printf(" P : extend (\"Project\") major tick marks outside the box (ignored if\n");
    printf("     option I is specified).\n");
    printf(" M : write numeric labels in the unconventional location above the\n");
    printf("     viewport (X) or to the right of the viewport (Y).\n");
    printf(" T : draw major Tick marks at the major coordinate interval.\n");
    printf(" S : draw minor tick marks (Subticks).\n");
    printf(" V : orient numeric labels Vertically. This is only applicable to Y.\n");
    printf("     The default is to write Y-labels parallel to the axis.\n");
    printf(" 1 : force decimal labelling, instead of automatic choice (see PGNUMB <#PGNUMB>).\n");
    printf(" 2 : force exponential labelling, instead of automatic.\n");
    printf("\n");
    printf("     The default is to write Y-labels parallel to the axis\n");
    printf(" \n");
    printf("\n");
    printf("       ******************        EXCEPTIONS       *******************\n");
    printf("\n");
    printf("       Note that \n");
    printf("         1) PGBOX <#PGBOX> option 'L' (log labels) is ignored with option 'Z'\n");
    printf("         2) The 'O' option will be ignored for the 'V' option as it \n");
    printf("            makes it impossible to align the labels nicely\n");
    printf("         3) Option 'Y' is forced with option 'D'\n");
    printf("\n");
    printf("       ***************************************************************\n");
    printf("\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGTEXT") == 0) {
    printf("    PGTEXT -- write text (horizontal, left-justified)\n");
    printf("\n");
    printf("\n");
    printf("void cpgtext(float x, float y, const char *text);\n");
    printf("\n");
    printf("      SUBROUTINE PGTEXT (X, Y, TEXT)\n");
    printf("      REAL X, Y\n");
    printf("      CHARACTER*(*) TEXT\n");
    printf("\n");
    printf("Write text. The bottom left corner of the first character is placed\n");
    printf("at the specified position, and the text is written horizontally.\n");
    printf("This is a simplified interface to the primitive routine PGPTXT <#PGPTXT>.\n");
    printf("For non-horizontal text, use PGPTXT <#PGPTXT>.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X      (input)  : world x-coordinate of start of string.\n");
    printf(" Y      (input)  : world y-coordinate of start of string.\n");
    printf(" TEXT   (input)  : the character string to be plotted.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGTICK") == 0) {
    printf("    PGTICK -- draw a single tick mark on an axis\n");
    printf("\n");
    printf("\n");
    printf("void cpgtick(float x1, float y1, float x2, float y2, float v, \\n");
    printf(" float tikl, float tikr, float disp, float orient, const char *str);\n");
    printf("\n");
    printf("      SUBROUTINE PGTICK (X1, Y1, X2, Y2, V, TIKL, TIKR, DISP, \n");
    printf("     :                   ORIENT, STR)\n");
    printf("      REAL X1, Y1, X2, Y2, V, TIKL, TIKR, DISP, ORIENT\n");
    printf("      CHARACTER*(*) STR\n");
    printf("\n");
    printf("Draw and label single tick mark on a graph axis. The tick mark is\n");
    printf("a short line perpendicular to the direction of the axis (which is not\n");
    printf("drawn by this routine). The optional text label is drawn with its\n");
    printf("baseline parallel to the axis and reading in the same direction as\n");
    printf("the axis (from point 1 to point 2). Current line and text attributes\n");
    printf("are used.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X1, Y1 (input)  : world coordinates of one endpoint of the axis.\n");
    printf(" X2, Y2 (input)  : world coordinates of the other endpoint of the axis.\n");
    printf(" V      (input)  : draw the tick mark at fraction V (0<=V<=1) along\n");
    printf("                   the line from (X1,Y1) to (X2,Y2).\n");
    printf(" TIKL   (input)  : length of tick mark drawn to left of axis\n");
    printf("                   (as seen looking from first endpoint to second), in\n");
    printf("                   units of the character height.\n");
    printf(" TIKR   (input)  : length of major tick marks drawn to right of axis,\n");
    printf("                   in units of the character height.\n");
    printf(" DISP   (input)  : displacement of label text to\n");
    printf("                   right of axis, in units of the character height.\n");
    printf(" ORIENT (input)  : orientation of label text, in degrees; angle between\n");
    printf("                   baseline of text and direction of axis (0-360 deg).\n");
    printf(" STR    (input)  : text of label (may be blank).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGUPDT") == 0) {
    printf("    PGUPDT -- update display\n");
    printf("\n");
    printf("\n");
    printf("void cpgupdt(void);\n");
    printf("\n");
    printf("      SUBROUTINE PGUPDT\n");
    printf("\n");
    printf("Update the graphics display: flush any pending commands to the\n");
    printf("output device. This routine empties the buffer created by PGBBUF <#PGBBUF>,\n");
    printf("but it does not alter the PGBBUF <#PGBBUF>/PGEBUF <#PGEBUF> counter. The routine should\n");
    printf("be called when it is essential that the display be completely up to\n");
    printf("date (before interaction with the user, for example) but it is not\n");
    printf("known if output is being buffered.\n");
    printf("\n");
    printf("Arguments: none\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGVECT") == 0) {
    printf("    PGVECT -- vector map of a 2D data array, with blanking\n");
    printf("\n");
    printf("\n");
    printf("void cpgvect(const float *a, const float *b, int idim, int jdim, \\n");
    printf(" int i1, int i2, int j1, int j2, float c, int nc, \\n");
    printf(" const float *tr, float blank);\n");
    printf("\n");
    printf("      SUBROUTINE PGVECT (A, B, IDIM, JDIM, I1, I2, J1, J2, C, NC, TR,\n");
    printf("     1                   BLANK)\n");
    printf("      INTEGER IDIM, JDIM, I1, I2, J1, J2, NC\n");
    printf("      REAL    A(IDIM,JDIM), B(IDIM, JDIM), TR(6), BLANK, C\n");
    printf("\n");
    printf("Draw a vector map of two arrays.  This routine is similar to\n");
    printf("PGCONB <#PGCONB> in that array elements that have the \"magic value\" defined by\n");
    printf("the argument BLANK are ignored, making gaps in the vector map.  The\n");
    printf("routine may be useful for data measured on most but not all of the\n");
    printf("points of a grid. Vectors are displayed as arrows; the style of the\n");
    printf("arrowhead can be set with routine PGSAH <#PGSAH>, and the the size of the\n");
    printf("arrowhead is determined by the current character size, set by PGSCH <#PGSCH>.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" A      (input)  : horizontal component data array.\n");
    printf(" B      (input)  : vertical component data array.\n");
    printf(" IDIM   (input)  : first dimension of A and B.\n");
    printf(" JDIM   (input)  : second dimension of A and B.\n");
    printf(" I1,I2  (input)  : range of first index to be mapped (inclusive).\n");
    printf(" J1,J2  (input)  : range of second index to be mapped (inclusive).\n");
    printf(" C      (input)  : scale factor for vector lengths, if 0.0, C will be\n");
    printf("                   set so that the longest vector is equal to the\n");
    printf("                   smaller of TR(2)+TR(3) and TR(5)+TR(6).\n");
    printf(" NC     (input)  : vector positioning code.\n");
    printf("                   <0 vector head positioned on coordinates\n");
    printf("                   >0 vector base positioned on coordinates\n");
    printf("                   =0 vector centered on the coordinates\n");
    printf(" TR     (input)  : array defining a transformation between the I,J\n");
    printf("                   grid of the array and the world coordinates. The\n");
    printf("                   world coordinates of the array point A(I,J) are\n");
    printf("                   given by:\n");
    printf("                     X = TR(1) + TR(2)*I + TR(3)*J\n");
    printf("                     Y = TR(4) + TR(5)*I + TR(6)*J\n");
    printf("                   Usually TR(3) and TR(5) are zero - unless the\n");
    printf("                   coordinate transformation involves a rotation\n");
    printf("                   or shear.\n");
    printf(" BLANK   (input) : elements of arrays A or B that are exactly equal to\n");
    printf("                   this value are ignored (blanked).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGVSIZ") == 0) {
    printf("    PGVSIZ -- set viewport (inches)\n");
    printf("\n");
    printf("\n");
    printf("void cpgvsiz(float xleft, float xright, float ybot, float ytop);\n");
    printf("\n");
    printf("      SUBROUTINE PGVSIZ (XLEFT, XRIGHT, YBOT, YTOP)\n");
    printf("      REAL XLEFT, XRIGHT, YBOT, YTOP\n");
    printf("\n");
    printf("Change the size and position of the viewport, specifying\n");
    printf("the viewport in physical device coordinates (inches).  The\n");
    printf("viewport is the rectangle on the view surface \"through\"\n");
    printf("which one views the graph.  All the PG routines which plot lines\n");
    printf("etc. plot them within the viewport, and lines are truncated at\n");
    printf("the edge of the viewport (except for axes, labels etc drawn with\n");
    printf("PGBOX <#PGBOX> or PGLAB <#PGLAB>).  The region of world space (the coordinate\n");
    printf("space of the graph) which is visible through the viewport is\n");
    printf("specified by a call to PGSWIN <#PGSWIN>.  It is legal to request a\n");
    printf("viewport larger than the view surface; only the part which\n");
    printf("appears on the view surface will be plotted.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" XLEFT  (input)  : x-coordinate of left hand edge of viewport, in\n");
    printf("                   inches from left edge of view surface.\n");
    printf(" XRIGHT (input)  : x-coordinate of right hand edge of viewport, in\n");
    printf("                   inches from left edge of view surface.\n");
    printf(" YBOT   (input)  : y-coordinate of bottom edge of viewport, in\n");
    printf("                   inches from bottom of view surface.\n");
    printf(" YTOP   (input)  : y-coordinate of top  edge of viewport, in inches\n");
    printf("                   from bottom of view surface.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGVSTD") == 0) {
    printf("    PGVSTD -- set standard (default) viewport\n");
    printf("\n");
    printf("\n");
    printf("void cpgvstd(void);\n");
    printf("\n");
    printf("      SUBROUTINE PGVSTD\n");
    printf("\n");
    printf("Define the viewport to be the standard viewport.  The standard\n");
    printf("viewport is the full area of the view surface (or panel),\n");
    printf("less a margin of 4 character heights all round for labelling.\n");
    printf("It thus depends on the current character size, set by PGSCH <#PGSCH>.\n");
    printf("\n");
    printf("Arguments: none.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGWEDG") == 0) {
    printf("    PGWEDG -- annotate an image plot with a wedge\n");
    printf("\n");
    printf("\n");
    printf("void cpgwedg(const char *side, float disp, float width, \\n");
    printf(" float fg, float bg, const char *label);\n");
    printf("\n");
    printf("      SUBROUTINE PGWEDG(SIDE, DISP, WIDTH, FG, BG, LABEL)\n");
    printf("      CHARACTER *(*) SIDE,LABEL\n");
    printf("      REAL DISP, WIDTH, FG, BG\n");
    printf("\n");
    printf("Plot an annotated grey-scale or color wedge parallel to a given axis\n");
    printf("of the the current viewport. This routine is designed to provide a\n");
    printf("brightness/color scale for an image drawn with PGIMAG <#PGIMAG> or PGGRAY <#PGGRAY>.\n");
    printf("The wedge will be drawn with the transfer function set by PGSITF <#PGSITF>\n");
    printf("and using the color index range set by PGSCIR <#PGSCIR>.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" SIDE   (input)  : The first character must be one of the characters\n");
    printf("                   'B', 'L', 'T', or 'R' signifying the Bottom, Left,\n");
    printf("                   Top, or Right edge of the viewport.\n");
    printf("                   The second character should be 'I' to use PGIMAG <#PGIMAG>\n");
    printf("                   to draw the wedge, or 'G' to use PGGRAY <#PGGRAY>.\n");
    printf(" DISP   (input)  : the displacement of the wedge from the specified\n");
    printf("                   edge of the viewport, measured outwards from the\n");
    printf("                   viewport in units of the character height. Use a\n");
    printf("                   negative value to write inside the viewport, a\n");
    printf("                   positive value to write outside.\n");
    printf(" WIDTH  (input)  : The total width of the wedge including annotation,\n");
    printf("                   in units of the character height.\n");
    printf(" FG     (input)  : The value which is to appear with shade\n");
    printf("                   1 (\"foreground\"). Use the values of FG and BG\n");
    printf("                   that were supplied to PGGRAY <#PGGRAY> or PGIMAG <#PGIMAG>.\n");
    printf(" BG     (input)  : the value which is to appear with shade\n");
    printf("                   0 (\"background\").\n");
    printf(" LABEL  (input)  : Optional units label. If no label is required\n");
    printf("                   use ' '.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGWNAD") == 0) {
    printf("    PGWNAD -- set window and adjust viewport to same aspect ratio\n");
    printf("\n");
    printf("\n");
    printf("void cpgwnad(float x1, float x2, float y1, float y2);\n");
    printf("\n");
    printf("      SUBROUTINE PGWNAD (X1, X2, Y1, Y2)\n");
    printf("      REAL X1, X2, Y1, Y2\n");
    printf("\n");
    printf("Change the window in world coordinate space that is to be mapped on\n");
    printf("to the viewport, and simultaneously adjust the viewport so that the\n");
    printf("world-coordinate scales are equal in x and y. The new viewport is\n");
    printf("the largest one that can fit within the previously set viewport\n");
    printf("while retaining the required aspect ratio.\n");
    printf("\n");
    printf("Arguments:\n");
    printf(" X1     (input)  : the x-coordinate of the bottom left corner\n");
    printf("                   of the viewport.\n");
    printf(" X2     (input)  : the x-coordinate of the top right corner\n");
    printf("                   of the viewport (note X2 may be less than X1).\n");
    printf(" Y1     (input)  : the y-coordinate of the bottom left corner\n");
    printf("                   of the viewport.\n");
    printf(" Y2     (input)  : the y-coordinate of the top right corner of the\n");
    printf("                   viewport (note Y2 may be less than Y1).\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGADVANCE") == 0) {
    printf("    PGADVANCE -- non-standard alias for PGPAGE\n");
    printf("\n");
    printf("      SUBROUTINE PGADVANCE\n");
    printf("\n");
    printf("See description of PGPAGE <#PGPAGE>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGBEGIN") == 0) {
    printf("    PGBEGIN -- non-standard alias for PGBEG\n");
    printf("\n");
    printf("      INTEGER FUNCTION PGBEGIN (UNIT, FILE, NXSUB, NYSUB)\n");
    printf("      INTEGER       UNIT\n");
    printf("      CHARACTER*(*) FILE\n");
    printf("      INTEGER       NXSUB, NYSUB\n");
    printf("\n");
    printf("See description of PGBEG <#PGBEG>.   \n");
    printf("\n");
  }else if(strcasecmp(substr, "PGCURSE") == 0) {
    printf("    PGCURSE -- non-standard alias for PGCURS\n");
    printf("\n");
    printf("      INTEGER FUNCTION PGCURSE (X, Y, CH)\n");
    printf("      REAL X, Y\n");
    printf("      CHARACTER*1 CH\n");
    printf("\n");
    printf("See description of PGCURS <#PGCURS>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGLABEL") == 0) {
    printf("    PGLABEL -- non-standard alias for PGLAB\n");
    printf("\n");
    printf("      SUBROUTINE PGLABEL (XLBL, YLBL, TOPLBL)\n");
    printf("      CHARACTER*(*) XLBL, YLBL, TOPLBL\n");
    printf("\n");
    printf("See description of PGLAB <#PGLAB>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGMTEXT") == 0) {
    printf("    PGMTEXT -- non-standard alias for PGMTXT\n");
    printf("\n");
    printf("      SUBROUTINE PGMTEXT (SIDE, DISP, COORD, FJUST, TEXT)\n");
    printf("      CHARACTER*(*) SIDE, TEXT\n");
    printf("      REAL DISP, COORD, FJUST\n");
    printf("\n");
    printf("See description of PGMTXT <#PGMTXT>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGNCURSE") == 0) {
    printf("    PGNCURSE -- non-standard alias for PGNCUR\n");
    printf("\n");
    printf("      SUBROUTINE PGNCURSE (MAXPT, NPT, X, Y, SYMBOL)\n");
    printf("      INTEGER MAXPT, NPT\n");
    printf("      REAL    X(*), Y(*)\n");
    printf("      INTEGER SYMBOL\n");
    printf("\n");
    printf("See description of PGNCUR <#PGNCUR>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGPAPER") == 0) {
    printf("    PGPAPER -- non-standard alias for PGPAP\n");
    printf("\n");
    printf("      SUBROUTINE PGPAPER (WIDTH, ASPECT)\n");
    printf("      REAL WIDTH, ASPECT\n");
    printf("\n");
    printf("See description of PGPAP <#PGPAP>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGPOINT") == 0) {
    printf("    PGPOINT -- non-standard alias for PGPT\n");
    printf("\n");
    printf("      SUBROUTINE PGPOINT (N, XPTS, YPTS, SYMBOL)\n");
    printf("      INTEGER N\n");
    printf("      REAL XPTS(*), YPTS(*)\n");
    printf("      INTEGER SYMBOL\n");
    printf("\n");
    printf("See description of PGPT <#PGPT>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGPTEXT") == 0) {
    printf("    PGPTEXT -- non-standard alias for PGPTXT\n");
    printf("\n");
    printf("      SUBROUTINE PGPTEXT (X, Y, ANGLE, FJUST, TEXT)\n");
    printf("      REAL X, Y, ANGLE, FJUST\n");
    printf("      CHARACTER*(*) TEXT\n");
    printf("\n");
    printf("See description of PGPTXT <#PGPTXT>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGVPORT") == 0) {
    printf("    PGVPORT -- non-standard alias for PGSVP\n");
    printf("\n");
    printf("      SUBROUTINE PGVPORT (XLEFT, XRIGHT, YBOT, YTOP)\n");
    printf("      REAL XLEFT, XRIGHT, YBOT, YTOP\n");
    printf("\n");
    printf("See description of PGSVP <#PGSVP>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGVSIZE") == 0) {
    printf("    PGVSIZE -- non-standard alias for PGVSIZ\n");
    printf("\n");
    printf("      SUBROUTINE PGVSIZE (XLEFT, XRIGHT, YBOT, YTOP)\n");
    printf("      REAL XLEFT, XRIGHT, YBOT, YTOP\n");
    printf("\n");
    printf("See description of PGVSIZ <#PGVSIZ>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGVSTAND") == 0) {
    printf("    PGVSTAND -- non-standard alias for PGVSTD\n");
    printf("\n");
    printf("      SUBROUTINE PGVSTAND\n");
    printf("\n");
    printf("See description of PGVSTD <#PGVSTD>.\n");
    printf("\n");
  }else if(strcasecmp(substr, "PGWINDOW") == 0) {
    printf("    PGWINDOW -- non-standard alias for PGSWIN\n");
    printf("\n");
    printf("      SUBROUTINE PGWINDOW (X1, X2, Y1, Y2)\n");
    printf("      REAL X1, X2, Y1, Y2\n");
    printf("\n");
    printf("See description of PGSWIN <#PGSWIN>.\n");
    printf("\n");
    printf("\n");
  }else {
    printf("No help topic available for '%s'.\n", substr);
  }
}
